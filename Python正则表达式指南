<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Python正则表达式指南 - AstralWind - 博客园</title>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common.css?id=20120623"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="http://common.cnblogs.com/Skins/Custom/style.css?id=20120623"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/blog/css/common2.css"/>
<link type="text/css" rel="stylesheet" href="http://common.cnblogs.com/css/shStyle.css"/>
<link type="text/css" rel="stylesheet" href="http://www.cnblogs.com/huxi/customcss.aspx?id=64145"/>
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/huxi/rss"/>
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/huxi/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/huxi/wlwmanifest.xml"/>
<script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">
var currentBlogApp = 'huxi';
</script>
<script src="http://common.cnblogs.com/blog/script/common.js?id=20120623" type="text/javascript"></script> 
<script src="http://common.cnblogs.com/script/json2.js" type="text/javascript"></script>
<script type="text/javascript" src="http://common.cnblogs.com/script/syntaxHighlighter.js"></script>
</head>
<body>
<a name="top"></a>

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="http://www.cnblogs.com/huxi/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/huxi/">AstralWind</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li><a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/huxi/">首页</a></li>
<li><a class="menu" href="http://q.cnblogs.com/">博问</a></li>
<li><a class="menu" href="http://home.cnblogs.com/ing/">闪存</a></li>
<li></li>
<li></li>
<li><a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/huxi/rss">订阅</a>
<!--<a id="MyLinks1_XMLLink" class="aHeaderXML" href="http://www.cnblogs.com/huxi/rss"><img src="/Skins/Custom/images/rss.gif" alt="订阅" /></a>--></li>
<li><a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://www.cnblogs.com/huxi/admin/EditPosts.aspx">管理</a></li>
</ul>
		<div class="blogStats">
			
			
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
	
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html">Python正则表达式指南</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body"><blockquote>   <p>本文介绍了Python对于正则表达式的支持，包括正则表达式基础以及Python正则表达式标准库的完整介绍及使用示例。本文的内容不包括如何编写高效的正则表达式、如何优化正则表达式，这些主题请查看其他教程。 </p>    <p>注意：本文基于Python2.4完成；如果看到不明白的词汇请记得百度谷歌或维基，whatever。 </p>    <p>尊重作者的劳动，转载请注明作者及原文地址 &gt;.&lt;<span style="color: #ffffff">html</span></p> </blockquote>  <h2>1. 正则表达式基础</h2>  <h3>1.1. 简单介绍</h3>  <p>正则表达式并不是Python的一部分。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。如果已经在其他语言里使用过正则表达式，只需要简单看一看就可以上手了。</p>  <p>下图展示了使用正则表达式进行匹配的流程：    <br /><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="re_simple" border="0" alt="re_simple" src="http://images.cnblogs.com/cnblogs_com/huxi/WindowsLiveWriter/Python_10A67/re_simple_38246a58-83be-4adf-9f30-6d735e9b9b47.png" width="474" height="212" /> </p>  <p>正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同，但也是很好理解的，看下图中的示例以及自己多使用几次就能明白。</p>  <p>下图列出了Python支持的正则表达式元字符和语法：&#160;&#160; <br /><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: ; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="pyre" border="0" alt="pyre" src="http://images.cnblogs.com/cnblogs_com/huxi/Windows-Live-Writer/Python_10A67/pyre_ebb9ce1c-e5e8-4219-a8ae-7ee620d5f9f1.png" width="799" height="1719" /></p>  <h3>1.2. 数量词的贪婪模式与非贪婪模式</h3>  <p>正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式&quot;ab*&quot;如果用于查找&quot;abbbc&quot;，将找到&quot;abbb&quot;。而如果使用非贪婪的数量词&quot;ab*?&quot;，将找到&quot;a&quot;。</p>  <h3>1.3. 反斜杠的困扰</h3>  <p>与大多数编程语言相同，正则表达式里使用&quot;\&quot;作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符&quot;\&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠&quot;\\\\&quot;：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r&quot;\\&quot;表示。同样，匹配一个数字的&quot;\\d&quot;可以写成r&quot;\d&quot;。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。</p>  <h3>1.4. 匹配模式</h3>  <p>正则表达式提供了一些可用的匹配模式，比如忽略大小写、多行匹配等，这部分内容将在Pattern类的工厂方法re.compile(pattern[, flags])中一起介绍。</p>  <h2>2. re模块</h2>  <h3>2.1. 开始使用re</h3>  <p>Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。</p>  <pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;"># encoding: UTF-8
import re

# 将正则表达式编译成Pattern对象
pattern = re.compile(r'hello')

# 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None
match = pattern.match('hello world!')

if match:
    # 使用Match获得分组信息
    print match.group()

### 输出 ###
# hello</pre>

<p><b>re.compile(strPattern[, flag]): </b></p>

<p>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符'|'表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile('pattern', re.I | re.M)与re.compile('(?im)pattern')是等价的。 
  <br />可选值有： </p>

<ul>
  <li>re.<b>I</b>(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） </li>

  <li><b>M</b>(MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图） </li>

  <li><b>S</b>(DOTALL): 点任意匹配模式，改变'.'的行为 </li>

  <li><b>L</b>(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定 </li>

  <li><b>U</b>(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性 </li>

  <li><b>X</b>(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的： </li>
</ul>

<pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">a = re.compile(r&quot;&quot;&quot;\d +  # the integral part
                   \.    # the decimal point
                   \d *  # some fractional digits&quot;&quot;&quot;, re.X)
b = re.compile(r&quot;\d+\.\d*&quot;)</pre>

<p>re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。这些方法将在Pattern类的实例方法部分一起介绍。如上面这个例子可以简写为：</p>

<pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">m = re.match(r'hello', 'hello world!')
print m.group()</pre>

<p>re模块还提供了一个方法<span style="font-family: courier new">escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。</span></p>

<h3>2.2. Match</h3>

<p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>

<p>属性：</p>

<ol>
  <li><b>string</b>: 匹配时使用的文本。 </li>

  <li><b>re</b>: 匹配时使用的Pattern对象。 </li>

  <li><b>pos</b>: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 </li>

  <li><b>endpos</b>: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 </li>

  <li><b>lastindex</b>: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 </li>

  <li><b>lastgroup</b>: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 </li>
</ol>

<p>方法：</p>

<ol>
  <li><b>group([group1, …]): </b>

    <br />获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 </li>

  <li><b>groups([default]):</b> 

    <br />以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 </li>

  <li><b>groupdict([default]): 
      <br /></b>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 </li>

  <li><b>start([group]):</b> 

    <br />返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 </li>

  <li><b>end([group]): 
      <br /></b>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 </li>

  <li><b>span([group]): 
      <br /></b>返回(start(group), end(group))。 </li>

  <li><b>expand(template):</b> 

    <br />将匹配到的分组代入template中然后返回。template中可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组，但不能使用编号0。\id与\g&lt;id&gt;是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符'0'，只能使用\g&lt;1&gt;0。 </li>
</ol>

<pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">import re
m = re.match(r'(\w+) (\w+)(?P&lt;sign&gt;.*)', 'hello world!')

print &quot;m.string:&quot;, m.string
print &quot;m.re:&quot;, m.re
print &quot;m.pos:&quot;, m.pos
print &quot;m.endpos:&quot;, m.endpos
print &quot;m.lastindex:&quot;, m.lastindex
print &quot;m.lastgroup:&quot;, m.lastgroup

print &quot;m.group(1,2):&quot;, m.group(1, 2)
print &quot;m.groups():&quot;, m.groups()
print &quot;m.groupdict():&quot;, m.groupdict()
print &quot;m.start(2):&quot;, m.start(2)
print &quot;m.end(2):&quot;, m.end(2)
print &quot;m.span(2):&quot;, m.span(2)
print r&quot;m.expand(r'\2 \1\3'):&quot;, m.expand(r'\2 \1\3')

### output ###
# m.string: hello world!
# m.re: &lt;_sre.SRE_Pattern object at 0x016E1A38&gt;
# m.pos: 0
# m.endpos: 12
# m.lastindex: 3
# m.lastgroup: sign
# m.group(1,2): ('hello', 'world')
# m.groups(): ('hello', 'world', '!')
# m.groupdict(): {'sign': '!'}
# m.start(2): 6
# m.end(2): 11
# m.span(2): (6, 11)
# m.expand(r'\2 \1\3'): world hello!</pre>

<h3>2.3. Pattern</h3>

<p>Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。</p>

<p>Pattern不能直接实例化，必须使用re.compile()进行构造。</p>

<p>Pattern提供了几个可读属性用于获取表达式的相关信息：</p>

<ol>
  <li>pattern: 编译时用的表达式字符串。 </li>

  <li>flags: 编译时用的匹配模式。数字形式。 </li>

  <li>groups: 表达式中分组的数量。 </li>

  <li>groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 </li>
</ol>

<pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">import re
p = re.compile(r'(\w+) (\w+)(?P&lt;sign&gt;.*)', re.DOTALL)

print &quot;p.pattern:&quot;, p.pattern
print &quot;p.flags:&quot;, p.flags
print &quot;p.groups:&quot;, p.groups
print &quot;p.groupindex:&quot;, p.groupindex

### output ###
# p.pattern: (\w+) (\w+)(?P&lt;sign&gt;.*)
# p.flags: 16
# p.groups: 3
# p.groupindex: {'sign': 3}</pre>

<p>实例方法[ | re模块方法]：</p>

<ol>
  <li><b>match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]): 
      <br /></b>这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 

    <br />pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 

    <br />注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符'$'。 

    <br />示例参见2.1小节。 </li>

  <li><b>search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]): 
      <br /></b>这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。 

    <br />pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 

    <br />

    <pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;"># encoding: UTF-8 
import re 

# 将正则表达式编译成Pattern对象 
pattern = re.compile(r'world') 

# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None 
# 这个例子中使用match()无法成功匹配 
match = pattern.search('hello world!') 

if match: 
    # 使用Match获得分组信息 
    print match.group() 

### 输出 ### 
# world </pre>
  </li>

  <li><b>split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]): 
      <br /></b>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 

    <br />

    <pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">import re

p = re.compile(r'\d+')
print p.split('one1two2three3four4')

### output ###
# ['one', 'two', 'three', 'four', '']</pre>
  </li>

  <li><b>findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]): 
      <br /></b>搜索string，以列表形式返回全部能匹配的子串。 

    <br />

    <pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">import re

p = re.compile(r'\d+')
print p.findall('one1two2three3four4')

### output ###
# ['1', '2', '3', '4']</pre>
  </li>

  <li><b>finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): 
      <br /></b>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。 

    <br />

    <pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">import re

p = re.compile(r'\d+')
for m in p.finditer('one1two2three3four4'):
    print m.group(),

### output ###
# 1 2 3 4</pre>
  </li>

  <li><b>sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]): 
      <br /></b>使用repl替换string中每一个匹配的子串后返回替换后的字符串。 

    <br />当repl是一个字符串时，可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组，但不能使用编号0。 

    <br />当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 

    <br />count用于指定最多替换次数，不指定时全部替换。 

    <br />

    <pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">import re

p = re.compile(r'(\w+) (\w+)')
s = 'i say, hello world!'

print p.sub(r'\2 \1', s)

def func(m):
    return m.group(1).title() + ' ' + m.group(2).title()

print p.sub(func, s)

### output ###
# say i, world hello!
# I Say, Hello World!</pre>
  </li>

  <li><b>subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): 
      <br /></b>返回 (sub(repl, string[, count]), 替换次数)。 

    <br />

    <pre class="brush: py; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;">import re

p = re.compile(r'(\w+) (\w+)')
s = 'i say, hello world!'

print p.subn(r'\2 \1', s)

def func(m):
    return m.group(1).title() + ' ' + m.group(2).title()

print p.subn(func, s)

### output ###
# ('say i, world hello!', 2)
# ('I Say, Hello World!', 2)</pre>
  </li>
</ol>

<p><b>以上就是Python对于正则表达式的支持。熟练掌握正则表达式是每一个程序员必须具备的技能，这年头没有不与字符串打交道的程序了。笔者也处于初级阶段，与君共勉，^_^</b></p>

<p><strong>另外，图中的特殊构造部分没有举出例子，用到这些的正则表达式是具有一定难度的。有兴趣可以思考一下，如何匹配不是以abc开头的单词，^_^</strong></p>

<p><b>全文结束</b></p></div><div id="MySignature"></div>
<script type="text/javascript">
var isLogined = false;
var cb_blogId = 64145;
var cb_entryId = 1771073;
var cb_blogApp = currentBlogApp;
var cb_blogUserGuid = "e63d8b8b-02e7-de11-ba8f-001cf0cd104b";
var cb_entryCreatedDate = '2010/7/4 23:56:00';
var enableGoogleAd = true;
var googletag = googletag || {};
googletag.cmd = googletag.cmd || [];
</script>
<div id="blog_post_info_block">
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
<script type="text/javascript">
    initBottomGoogleAd();
</script>
<script type="text/javascript">
    $(function () {       
        fixPostBodyFormat();
        loadBottomGoogleAd();
        loadBlogSignature();
        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
        showEditorOpt();
        loadNewsAndKb();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
        loadAdUnderGoogle();
    });
</script>
		</div>
		<div class = "postDesc">posted @ <span id="post-date">2010-07-04 23:56</span> <a href='http://www.cnblogs.com/huxi/'>AstralWind</a> 阅读(43510) 评论(<span id="post-comment-count">28</span>)  <a href ="http://www.cnblogs.com/huxi/admin/EditPosts.aspx?postid=1771073" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(1771073);return false;">收藏</a></div>
	</div>
	<img src ="http://www.cnblogs.com/huxi/aggbug/1771073.html?type=1&amp;webview=1" width="1" height="1" alt=""/>
	
</div><!--end: topics 文章、评论容器-->
<div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.loadComments();</script>
<div id="comment_form" class="commentform">
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
<div id="comment_form_container"></div>

<script type="text/javascript">
    if (typeof commentManager === 'undefined') {
        commentManager = new blogCommentManager();
    }
    commentManager.loadCommentForm();   
</script>

<div class="ad_text_commentbox"><a href="http://q.cnblogs.com/" target="_blank">程序员问答社区，解决您的技术难题</a></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="程序员的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a><div id="site_editor_opt"></div></div>
<script type="text/javascript">
enableGoogleAd = true;
if ($("#cnblogs_post_body").text().length < 1000) {
    enableGoogleAd = false;
}
</script>
<div id="google_ad_c1" class="c_ad_block">
<div id='div-gpt-ad-1320933818841-0' style='width:300px; height:250px;'>
<script type='text/javascript'>
    if (enableGoogleAd) {
        try {
            googletag.cmd.push(function () { googletag.display('div-gpt-ad-1320933818841-0'); });
        } catch (e) { }
    } else {
        $('#google_ad_c1').hide();
    }
</script>
</div>
</div>
<div id="blog-news-kb"></div>
<div id="google_ad_c2" class="c_ad_block">
<div id='div-gpt-ad-1320933818841-1' style='width:468px; height:60px;'>
<script type='text/javascript'>
    if (enableGoogleAd) {
        try {
            googletag.cmd.push(function () { googletag.display('div-gpt-ad-1320933818841-1'); });
        } catch (e) { }
    } else {
        $('#google_ad_c2').hide();
    }
</script>
</div>
</div>
<div id="ad_under_google" class="c_ad_block" style="display:none;"></div>
<div id="HistoryToday" class="c_ad_block"></div>
</div>





	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
			<div id="blog-calendar" style="displya:none"></div>
			
			<DIV id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
			</DIV>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2012 AstralWind
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->
<script type="text/javascript" src="http://common.cnblogs.com/script/google-analytics.js"></script>
</body>
</html>
