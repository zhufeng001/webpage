<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" /><title>QEMU - ArchWiki</title>
<meta name="generator" content="MediaWiki 1.22.4" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="ArchWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.archlinux.org/api.php?action=rsd" />
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
<link rel="alternate" type="application/atom+xml" title="ArchWiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wiki.archlinux.org/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.archlinux&amp;only=styles&amp;skin=archlinux&amp;*" />
<!--[if IE 6]><link rel="stylesheet" href="/skins/archlinux/IE60Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/skins/archlinux/IE70Fixes.css?303" media="screen" /><![endif]--><meta name="ResourceLoaderDynamicStyles" content="" />

<script src="https://wiki.archlinux.org/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=archlinux&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"QEMU","wgTitle":"QEMU","wgCurRevisionId":307115,"wgRevisionId":307115,"wgArticleId":1173,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Emulators","Virtualization"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"QEMU","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"archlinux","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":
0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: archwiki:resourceloader:filter:minify-js:7:85c90aa16eaeef41f8c16fb94950cfbf */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-QEMU skin-archlinux action-view">

<div id="archnavbar"><!-- Arch Linux global navigation bar -->
	<div id="archnavbarlogo">
		<p><a id="logo" href="http://www.archlinux.org/"></a></p>
	</div>
	<div id="archnavbarmenu">
		<ul id="archnavbarlist">
			<li id="anb-home"><a href="http://www.archlinux.org/">Home</a></li><li id="anb-packages"><a href="http://www.archlinux.org/packages/">Packages</a></li><li id="anb-forums"><a href="https://bbs.archlinux.org/">Forums</a></li><li id="anb-wiki" class="anb-selected"><a href="https://wiki.archlinux.org/">Wiki</a></li><li id="anb-bugs"><a href="https://bugs.archlinux.org/">Bugs</a></li><li id="anb-aur"><a href="https://aur.archlinux.org/">AUR</a></li><li id="anb-download"><a href="http://www.archlinux.org/download/">Download</a></li>		</ul>
	</div>
</div><!-- #archnavbar -->

<div id="globalWrapper">
<div id="column-content"><div id="content" class="mw-body-primary" role="main">
	<a id="top"></a>
	
	<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">QEMU</span></h1>
	<div id="bodyContent" class="mw-body">
		<div id="siteSub">From ArchWiki</div>
		<div id="contentSub"></div>
		<div id="jump-to-nav" class="mw-jump">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>

		<!-- start content -->
<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div style="float:right; clear:right; width:25%; margin: 0 0 0.5em 0.5em;"><p style="background:#333; color:white; padding:0.2em; border-bottom:5px #08c solid; margin:0; text-align:center; font-weight:bold;">Related articles</p><ul style="list-style-type:none; margin:0; padding:0.3em;">
<li style="padding:0.4em 0; line-height:1;"><a href="/index.php/KVM" title="KVM">KVM</a></li>
<li style="padding:0.4em 0; line-height:1;"><a href="/index.php/Libvirt" title="Libvirt">Libvirt</a></li>
<li style="padding:0.4em 0; line-height:1;"><a href="/index.php/VirtualBox" title="VirtualBox">VirtualBox</a></li>
<li style="padding:0.4em 0; line-height:1;"><a href="/index.php/Xen" title="Xen">Xen</a></li>
<li style="padding:0.4em 0; line-height:1;"><a href="/index.php/VMware" title="VMware">VMware</a></li>
</ul></div>
<p>From the <a rel="nofollow" class="external text" href="http://wiki.qemu.org/Main_Page">QEMU about page</a>:
</p>
<dl>
<dd><i>QEMU is a generic and open source machine emulator and virtualizer.</i>
</dd>
</dl>
<p>When used as a machine emulator, QEMU can run OSes and programs made for one machine (e.g. an ARM board) on a different machine (e.g. your x86 PC). By using dynamic translation, it achieves very good performance.
</p><p>QEMU can use other hypervisors like <a href="/index.php/Xen" title="Xen">Xen</a> or <a href="/index.php/KVM" title="KVM">KVM</a> to use CPU extensions (<a href="http://en.wikipedia.org/wiki/Hardware-assisted_virtualization" class="extiw" title="wikipedia:Hardware-assisted virtualization">HVM</a>) for virtualization. When used as a virtualizer, QEMU achieves near native performances by executing the guest code directly on the host CPU.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Installing_QEMU"><span class="tocnumber">1</span> <span class="toctext">Installing QEMU</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Graphical_front-ends_for_QEMU"><span class="tocnumber">2</span> <span class="toctext">Graphical front-ends for QEMU</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Running_virtualized_system"><span class="tocnumber">3</span> <span class="toctext">Running virtualized system</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Enabling_KVM"><span class="tocnumber">3.1</span> <span class="toctext">Enabling KVM</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Creating_new_virtualized_system"><span class="tocnumber">4</span> <span class="toctext">Creating new virtualized system</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Creating_a_hard_disk_image"><span class="tocnumber">4.1</span> <span class="toctext">Creating a hard disk image</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Overlay_storage_images"><span class="tocnumber">4.1.1</span> <span class="toctext">Overlay storage images</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Resizing_an_image"><span class="tocnumber">4.1.2</span> <span class="toctext">Resizing an image</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="#Preparing_the_installation_media"><span class="tocnumber">4.2</span> <span class="toctext">Preparing the installation media</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Installing_the_operating_system"><span class="tocnumber">4.3</span> <span class="toctext">Installing the operating system</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Moving_data_between_host_and_guest_OS"><span class="tocnumber">5</span> <span class="toctext">Moving data between host and guest OS</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Network"><span class="tocnumber">5.1</span> <span class="toctext">Network</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#QEMU.27s_built-in_SMB_server"><span class="tocnumber">5.2</span> <span class="toctext">QEMU's built-in SMB server</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Mounting_a_partition_inside_a_raw_disk_image"><span class="tocnumber">5.3</span> <span class="toctext">Mounting a partition inside a raw disk image</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#With_manually_specifying_byte_offset"><span class="tocnumber">5.3.1</span> <span class="toctext">With manually specifying byte offset</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#With_loop_module_autodetecting_partitions"><span class="tocnumber">5.3.2</span> <span class="toctext">With loop module autodetecting partitions</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#With_kpartx"><span class="tocnumber">5.3.3</span> <span class="toctext">With kpartx</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="#Mounting_a_partition_inside_a_qcow2_image"><span class="tocnumber">5.4</span> <span class="toctext">Mounting a partition inside a qcow2 image</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Using_any_real_partition_as_the_single_primary_partition_of_a_hard_disk_image"><span class="tocnumber">5.5</span> <span class="toctext">Using any real partition as the single primary partition of a hard disk image</span></a>
<ul>
<li class="toclevel-3 tocsection-20"><a href="#By_specifying_kernel_and_initrd_manually"><span class="tocnumber">5.5.1</span> <span class="toctext">By specifying kernel and initrd manually</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Simulate_virtual_disk_with_MBR_using_linear_RAID"><span class="tocnumber">5.5.2</span> <span class="toctext">Simulate virtual disk with MBR using linear RAID</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="#Networking"><span class="tocnumber">6</span> <span class="toctext">Networking</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Link-level_address_caveat"><span class="tocnumber">6.1</span> <span class="toctext">Link-level address caveat</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#User-mode_networking"><span class="tocnumber">6.2</span> <span class="toctext">User-mode networking</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Tap_networking_with_QEMU"><span class="tocnumber">6.3</span> <span class="toctext">Tap networking with QEMU</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="#Host-only_networking"><span class="tocnumber">6.3.1</span> <span class="toctext">Host-only networking</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Internal_networking"><span class="tocnumber">6.3.2</span> <span class="toctext">Internal networking</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Bridged_networking_using_qemu-bridge-helper"><span class="tocnumber">6.3.3</span> <span class="toctext">Bridged networking using qemu-bridge-helper</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#Creating_bridge_manually"><span class="tocnumber">6.3.4</span> <span class="toctext">Creating bridge manually</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-30"><a href="#Networking_with_VDE2"><span class="tocnumber">6.4</span> <span class="toctext">Networking with VDE2</span></a>
<ul>
<li class="toclevel-3 tocsection-31"><a href="#What_is_VDE.3F"><span class="tocnumber">6.4.1</span> <span class="toctext">What is VDE?</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#Basics"><span class="tocnumber">6.4.2</span> <span class="toctext">Basics</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Startup_scripts"><span class="tocnumber">6.4.3</span> <span class="toctext">Startup scripts</span></a></li>
<li class="toclevel-3 tocsection-34"><a href="#Alternative_method"><span class="tocnumber">6.4.4</span> <span class="toctext">Alternative method</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-35"><a href="#VDE2_Bridge"><span class="tocnumber">6.5</span> <span class="toctext">VDE2 Bridge</span></a>
<ul>
<li class="toclevel-3 tocsection-36"><a href="#Basics_2"><span class="tocnumber">6.5.1</span> <span class="toctext">Basics</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#Startup_scripts_2"><span class="tocnumber">6.5.2</span> <span class="toctext">Startup scripts</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-38"><a href="#Graphics"><span class="tocnumber">7</span> <span class="toctext">Graphics</span></a>
<ul>
<li class="toclevel-2 tocsection-39"><a href="#std"><span class="tocnumber">7.1</span> <span class="toctext">std</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="#vmware"><span class="tocnumber">7.2</span> <span class="toctext">vmware</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="#qxl"><span class="tocnumber">7.3</span> <span class="toctext">qxl</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#none"><span class="tocnumber">7.4</span> <span class="toctext">none</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="#vnc"><span class="tocnumber">7.5</span> <span class="toctext">vnc</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-44"><a href="#Installing_virtio_drivers"><span class="tocnumber">8</span> <span class="toctext">Installing virtio drivers</span></a>
<ul>
<li class="toclevel-2 tocsection-45"><a href="#Preparing_an_.28Arch.29_Linux_guest"><span class="tocnumber">8.1</span> <span class="toctext">Preparing an (Arch) Linux guest</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="#Preparing_a_Windows_guest"><span class="tocnumber">8.2</span> <span class="toctext">Preparing a Windows guest</span></a>
<ul>
<li class="toclevel-3 tocsection-47"><a href="#Block_device_drivers"><span class="tocnumber">8.2.1</span> <span class="toctext">Block device drivers</span></a></li>
<li class="toclevel-3 tocsection-48"><a href="#Network_drivers"><span class="tocnumber">8.2.2</span> <span class="toctext">Network drivers</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-49"><a href="#Preparing_a_FreeBSD_guest"><span class="tocnumber">8.3</span> <span class="toctext">Preparing a FreeBSD guest</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-50"><a href="#Tips_and_tricks"><span class="tocnumber">9</span> <span class="toctext">Tips and tricks</span></a>
<ul>
<li class="toclevel-2 tocsection-51"><a href="#Starting_QEMU_virtual_machines_on_boot"><span class="tocnumber">9.1</span> <span class="toctext">Starting QEMU virtual machines on boot</span></a>
<ul>
<li class="toclevel-3 tocsection-52"><a href="#With_libvirt"><span class="tocnumber">9.1.1</span> <span class="toctext">With libvirt</span></a></li>
<li class="toclevel-3 tocsection-53"><a href="#Custom_script"><span class="tocnumber">9.1.2</span> <span class="toctext">Custom script</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-54"><a href="#Mouse_integration"><span class="tocnumber">9.2</span> <span class="toctext">Mouse integration</span></a></li>
<li class="toclevel-2 tocsection-55"><a href="#Pass-through_host_USB_device"><span class="tocnumber">9.3</span> <span class="toctext">Pass-through host USB device</span></a></li>
<li class="toclevel-2 tocsection-56"><a href="#Enabling_KSM"><span class="tocnumber">9.4</span> <span class="toctext">Enabling KSM</span></a></li>
<li class="toclevel-2 tocsection-57"><a href="#Spice_support"><span class="tocnumber">9.5</span> <span class="toctext">Spice support</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="#Copy_and_paste"><span class="tocnumber">9.6</span> <span class="toctext">Copy and paste</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#Windows-specific_notes"><span class="tocnumber">9.7</span> <span class="toctext">Windows-specific notes</span></a>
<ul>
<li class="toclevel-3 tocsection-60"><a href="#Remote_Desktop_Protocol"><span class="tocnumber">9.7.1</span> <span class="toctext">Remote Desktop Protocol</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-61"><a href="#Troubleshooting"><span class="tocnumber">10</span> <span class="toctext">Troubleshooting</span></a>
<ul>
<li class="toclevel-2 tocsection-62"><a href="#Mouse_cursor_is_jittery_or_erratic"><span class="tocnumber">10.1</span> <span class="toctext">Mouse cursor is jittery or erratic</span></a></li>
<li class="toclevel-2 tocsection-63"><a href="#Keyboard_seems_broken_or_the_arrow_keys_do_not_work"><span class="tocnumber">10.2</span> <span class="toctext">Keyboard seems broken or the arrow keys do not work</span></a></li>
<li class="toclevel-2 tocsection-64"><a href="#Virtual_machine_runs_too_slowly"><span class="tocnumber">10.3</span> <span class="toctext">Virtual machine runs too slowly</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-65"><a href="#See_also"><span class="tocnumber">11</span> <span class="toctext">See also</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Installing_QEMU">Installing QEMU</span></h2>
<p>Install <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=qemu">qemu</a></span> from the <a href="/index.php/Official_repositories" title="Official repositories">official repositories</a>.
</p>
<h2><span class="mw-headline" id="Graphical_front-ends_for_QEMU">Graphical front-ends for QEMU</span></h2>
<p>Unlike other virtualization programs such as <a href="/index.php/VirtualBox" title="VirtualBox">VirtualBox</a> and <a href="/index.php/VMware" title="VMware">VMware</a>, QEMU does not provide a GUI to manage virtual machines (other than the window that appears when running a virtual machine), nor does it provide a way to create persistent virtual machines with saved settings.  All parameters to run a virtual machine must be specified on the command line at every launch, unless you have created a custom script to start your virtual machine(s).  However, there are several GUI front-ends for QEMU:
</p>
<ul>
<li> <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=virt-manager">virt-manager</a></span> (part of <a href="/index.php/Libvirt" title="Libvirt">libvirt</a>)
</li>
<li> <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=qemu-launcher">qemu-launcher</a></span>
</li>
<li> <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=qtemu">qtemu</a></span>
</li>
</ul>
<p>From AUR:
</p>
<ul>
<li> <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/aqemu-git/">aqemu-git</a></span>
</li>
<li> <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/qemulator/">qemulator</a></span>
</li>
<li> <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/gnome-boxes/">gnome-boxes</a></span>
</li>
</ul>
<h2><span class="mw-headline" id="Running_virtualized_system">Running virtualized system</span></h2>
<p><code style="display:inline-block; padding: 0.1em 0.3em;">qemu-system-*</code> binaries (for example <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-system-i386</code> or <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-system-x86_64</code>, depending on emulated architecture) are used to run the virtualized system. The usage is:
</p>
<pre>$ qemu-system-i386 <i>options</i> <i>disk_image</i>
</pre>
<p>Options are the same for all <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-system-*</code> binaries, see <code style="display:inline-block; padding: 0.1em 0.3em;">qemu(1)</code> for documentation of all options.
</p><p>By default, QEMU will show the virtual machine's video output in a window. One thing to keep in mind: when you click inside the QEMU window, the mouse pointer is grabbed. To release it, press <code style="display:inline-block; padding: 0.1em 0.3em;">Ctrl+Alt</code>.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;"><strong> Warning: </strong>QEMU should never be run as root.  If you must launch it in a script as root, you should use the <code style="display:inline-block; padding: 0.1em 0.3em;">-runas</code> option to make QEMU drop root privileges.</div>
<h3><span class="mw-headline" id="Enabling_KVM">Enabling KVM</span></h3>
<p>KVM must be supported by your processor and kernel, and necessary <a href="/index.php/Kernel_modules" title="Kernel modules">kernel modules</a> must be loaded. See <a href="/index.php/KVM" title="KVM">KVM</a> for more information.
</p><p>To start QEMU in KVM mode, append <code style="display:inline-block; padding: 0.1em 0.3em;">-enable-kvm</code> to the additional start options.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>If you start your VM with a GUI tool and experience very bad performance, you should check for proper KVM support, as QEMU may be falling back to software emulation.</div>
<h2><span class="mw-headline" id="Creating_new_virtualized_system">Creating new virtualized system</span></h2>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>If you are virtualizing Arch Linux, it is possible to create a disk image directly on an existing Arch Linux system, see <a href="/index.php/Creating_Arch_Linux_disk_image#Install_Arch_Linux_in_a_disk_image_without_the_installation_media" title="Creating Arch Linux disk image">Creating Arch Linux disk image#Install Arch Linux in a disk image without the installation media</a> for details.</div>
<h3><span class="mw-headline" id="Creating_a_hard_disk_image">Creating a hard disk image</span></h3>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>See the <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU/Images">QEMU Wikibook</a> for more information on QEMU images.</div>
<p>To run QEMU you will need a hard disk image, unless you are booting a live system from CD-ROM or the network (and not doing so to install an operating system to a hard disk image).  A hard disk image is a file which stores the contents of the emulated hard disk.  
</p><p>A hard disk image can be <i>raw</i>, so that it is literally byte-by-byte the same as what the guest sees, and will always use the full capacity of the guest hard drive on the host. This method provides the least I/O overhead, but can waste a lot of space, as not-used space on the guest cannot be used on the host.
</p><p>Alternatively, the hard disk image can be in a format such as <i>qcow2</i> which only allocates space to the image file when the guest operating system actually writes to those sectors on its virtual hard disk. The image appears as the full size to the guest operating system, even though it may take up only a very small amount of space on the host system. Using this format instead of <i>raw</i> will likely affect performance.
</p><p>QEMU provides the <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-img</code> command to create hard disk images.  For example to create a 4 GB image in the <i>raw</i> format:
</p>
<pre>$ qemu-img create -f raw <i>image_file</i> 4G
</pre>
<p>You may use <code style="display:inline-block; padding: 0.1em 0.3em;">-f qcow2</code> to create a <i>gcow2</i> disk instead.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>You can also simply create a <i>raw</i> image by creating a file of the needed size using <code style="display:inline-block; padding: 0.1em 0.3em;">dd</code> or <code style="display:inline-block; padding: 0.1em 0.3em;">fallocate</code>.</div>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;"><strong> Warning: </strong>If you store the hard disk images on a <a href="/index.php/Btrfs" title="Btrfs">Btrfs</a> file system, you should consider disabling <a href="/index.php/Btrfs#Copy-On-Write_.28CoW.29" title="Btrfs">Copy-on-Write</a> for the directory before creating any images.</div>
<h4><span class="mw-headline" id="Overlay_storage_images">Overlay storage images</span></h4>
<p>You can create a storage image once (the 'backing' image) and have QEMU keep mutations to this image in an overlay image. This allows you to revert to a previous state of this storage image. You could revert by creating a new overlay image at the time you wish to revert, based on the original backing image.
</p><p>To create an overlay image, issue a command like:
</p>
<pre>$ qemu-img create -b <i>backing_image.qemu.raw</i> -f qcow2 <i>image.qemu.raw.overlay.1</i>
</pre>
<p>After that you can run your QEMU VM as usual (see <a href="#Running_virtualized_system">#Running virtualized system</a>):
</p>
<pre>$ qemu-system-i386 <i>image.qemu.raw.overlay.1</i>
</pre>
<p>The backing image will then be left intact and mutations to this storage will be recorded in the overlay image file.
</p><p>When the path to the backing image changes, repair is required. 
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;"><strong> Warning: </strong>The backing image's absolute filesystem path is stored in the (binary) overlay image file. Changing the backing image's path requires some effort.</div>
<p>Make sure that the original backing image's path still leads to this image. If necessary, make a symbolic link at the original path to the new path. Then issue a command like: 
</p>
<pre>$ qemu-img rebase -b <i>/new/backing_image.qemu.raw</i> <i>/new/image.qemu.raw.overlay.1</i>
</pre>
<p>At your discretion, you may alternatively perform an 'unsafe' rebase where the old path to the backing image is not checked: 
</p>
<pre>$ qemu-img rebase -u -b <i>/new/backing_image.qemu.raw</i> <i>/new/image.qemu.raw.overlay.1</i>
</pre>
<h4><span class="mw-headline" id="Resizing_an_image">Resizing an image</span></h4>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;"><strong> Warning: </strong>Resizing an image containing an NTFS boot file system could make the VM installed on it unbootable. For full explanation see <a rel="nofollow" class="external text" href="http://tjworld.net/wiki/Howto/ResizeQemuDiskImages">here</a> and workaround below.</div>
<p>The <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-img</code> executable has the <code style="display:inline-block; padding: 0.1em 0.3em;">resize</code> option, which enables easy resizing of a hard drive image. It works for both <i>raw</i> and <i>qcow2</i>. For example, to increase image space by 10 GB, run:
</p>
<pre>$ qemu-img resize <i>disk_image</i> +10G
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>Workaround resizing an image containing an NTFS boot file system (this example is for qcow2 format image but method is the same for other formats):
<p>Important: first shut down any VMs using the image!
</p><p>Then convert to raw format, add space at the end, and convert back again:
</p>
<pre>$ qemu-img convert -f qcow2 -O raw myimg.qcow2 myimg.raw  # (creates raw format copy of disk image)
$ truncate -s +4G myimg.raw                               # (adds 4 GB blank space at the end of the image file)
$ mv myimg.qcow2 myimg.qcow2.bak                          # (keep the original image as backup - can delete later once everything is working)
$ qemu-img convert -f raw -O qcow2 myimg.raw myimg.qcow2  # (convert the enlarged raw image back to qcow2)
$ rm myimg.raw                                            # (delete the raw image since we will not be using it)
$ chown --reference=myimg.qcow2.bak myimg.qcow2           # (match original image file ownerhip)
$ chmod --reference=myimg.qcow2.bak myimg.qcow2           # (match original image file permissions)
</pre>
Then resize partitions using preferred tool (e.g. for Windows Vista or later, you can just boot Windows and use the built-in <a rel="nofollow" class="external text" href="http://www.howtogeek.com/howto/windows-vista/resize-a-partition-for-free-in-windows-vista/">Disk Management utility</a>).</div>
<h3><span class="mw-headline" id="Preparing_the_installation_media">Preparing the installation media</span></h3>
<p>To install an operating system into your disk image, you need the installation medium (e.g. optical disk, USB-drive, or ISO image) for the operating system. The installation medium should not be mounted because QEMU accesses the media directly. 
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>If using an optical disk, it is a good idea to first dump the media to a file because this both improves performance and does not require you to have direct access to the devices (that is, you can run QEMU as a regular user without having to change access permissions on the media's device file).  For example, if the CD-ROM device node is named <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/cdrom</code>, you can dump it to a file with the command: <pre>$ dd if=/dev/cdrom of=<i>cd_image.iso</i></pre></div>
<h3><span class="mw-headline" id="Installing_the_operating_system">Installing the operating system</span></h3>
<p>This is the first time you will need to start the emulator. To install the operating system on the disk image, you must attach both the disk image and the installation media to the virtual machine, and have it boot from the installation media.
</p><p>For example on i386 systems, to install from a bootable ISO file as CD-ROM:
</p>
<pre>$ qemu-system-i386 -cdrom <i>iso_image</i> -boot order=d <i>qemu_image</i>
</pre>
<p>See <code style="display:inline-block; padding: 0.1em 0.3em;">qemu(1)</code> for information about loading other media types, such as floppy or disk images, or physical drives.
</p><p>After the operating system has finished installing, the QEMU image can be booted directly (see <a href="#Running_virtualized_system">#Running virtualized system</a>).
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>
<ul>
<li> By default only 128 MB of memory is assigned to the machine. The amount of memory can be adjusted with the <code style="display:inline-block; padding: 0.1em 0.3em;">-m</code> switch, for example <code style="display:inline-block; padding: 0.1em 0.3em;">-m 512</code>.
</li>
<li> Instead of specifying <code style="display:inline-block; padding: 0.1em 0.3em;">-boot order=x</code>, some users may feel more comfortable using a boot menu: <code style="display:inline-block; padding: 0.1em 0.3em;">-boot menu=on</code>, at least during configuration and experimentation.
</li>
<li> If you need to replace floppies or CDs as part of the installation process, you can use the QEMU machine monitor (press <code style="display:inline-block; padding: 0.1em 0.3em;">Ctrl+Alt+2</code> in the virtual machine's window) to remove and attach storage devices to a virtual machine. Type <code style="display:inline-block; padding: 0.1em 0.3em;">info block</code> to see the block devices, and use the <code style="display:inline-block; padding: 0.1em 0.3em;">change</code> command to swap out a device. Press <code style="display:inline-block; padding: 0.1em 0.3em;">Ctrl+Alt+1</code> to go back to the virtual machine.</div>
</li>
</ul>
<h2><span class="mw-headline" id="Moving_data_between_host_and_guest_OS">Moving data between host and guest OS</span></h2>
<h3><span class="mw-headline" id="Network">Network</span></h3>
<p>Data can be shared between the host and guest OS using any network protocol that can transfer files, such as <a href="/index.php/NFS" title="NFS">NFS</a>, <a href="/index.php/Samba" title="Samba">SMB</a>, <a href="http://en.wikipedia.org/wiki/Network_Block_Device" class="extiw" title="wikipedia:Network Block Device">NBD</a>, HTTP, <a href="/index.php/Very_Secure_FTP_Daemon" title="Very Secure FTP Daemon">FTP</a>, or <a href="/index.php/Secure_Shell" title="Secure Shell">SSH</a>, provided that you have set up the network appropriately and enabled the appropriate services.
</p><p>The default user-mode networking allows the guest to access the host OS at the IP address 10.0.2.2.  Any servers that you are running on your host OS, such as a SSH server or SMB server, will be accessible at this IP address.  So on the guests, you can mount directories exported on the host via <a href="/index.php/Samba" title="Samba">SMB</a> or <a href="/index.php/NFS" title="NFS">NFS</a>, or you can access the host's HTTP server, etc. 
It will not be possible for the host OS to access servers running on the guest OS, but this can be done with other network configurations (see <a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a>).
</p>
<h3><span class="mw-headline" id="QEMU.27s_built-in_SMB_server">QEMU's built-in SMB server</span></h3>
<p>QEMU's documentation says it has a "built-in" SMB server, but actually it just starts up <a href="/index.php/Samba" title="Samba">Samba</a> with an automatically generated configuration file and makes it accessible to the guest at a different IP address (10.0.2.4 by default).  This only works for user networking, and this is not necessarily very useful since the guest can also access the normal <a href="/index.php/Samba" title="Samba">Samba</a> service on the host if you have set up shares on it.
</p><p>To enable this feature, start QEMU with a command like:
</p>
<pre>$ qemu-system-i386 <i>disk_image</i> -net nic -net user,smb=<i>shared_dir_path</i>
</pre>
<p>where <code style="display:inline-block; padding: 0.1em 0.3em;"><i>shared_dir_path</i></code> is a directory that you want to share between the guest and host.
</p><p>Then, in the guest, you will be able to access the shared directory on the host 10.0.2.4 with the share name "qemu".  For example, in Windows Explorer you would go to <code style="display:inline-block; padding: 0.1em 0.3em;">\\10.0.2.4\qemu</code>.
</p>
<h3><span class="mw-headline" id="Mounting_a_partition_inside_a_raw_disk_image">Mounting a partition inside a raw disk image</span></h3>
<p>When the virtual machine is not running, it is possible to mount partitions that are inside a raw disk image file by setting them up as loopback devices.  This does not work with disk images in special formats, such as qcow2, although those can be mounted using <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-nbd</code>.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;"><strong> Warning: </strong>You must make sure to unmount the partitions before running the virtual machine again. Otherwise data corruption could occur, unless you had mounted the partitions read-only.</div>
<h4><span class="mw-headline" id="With_manually_specifying_byte_offset">With manually specifying byte offset</span></h4>
<p>One way to mount a disk image partition is to mount the disk image at a certain offset using a command like the following:
</p>
<pre># mount -o loop,offset=32256 <i>disk_image</i> <i>mountpoint</i>
</pre>
<p>The <code style="display:inline-block; padding: 0.1em 0.3em;">offset=32256</code> option is actually passed to the <code style="display:inline-block; padding: 0.1em 0.3em;">losetup</code> program to set up a loopback device that starts at byte offset 32256 of the file and continues to the end.  This loopback device is then mounted. You may also use the <code style="display:inline-block; padding: 0.1em 0.3em;">sizelimit</code> option to specify the exact size of the partition, but this is usually unnecessary.
</p><p>Depending on your disk image, the needed partition may not start at offset 32256. Run <code style="display:inline-block; padding: 0.1em 0.3em;">fdisk -l <i>disk_image</i></code> to see the partitions in the image. fdisk gives the start and end offsets in 512-byte sectors, so multiply by 512 to get the correct offset to pass to <code style="display:inline-block; padding: 0.1em 0.3em;">mount</code>.
</p>
<h4><span class="mw-headline" id="With_loop_module_autodetecting_partitions">With loop module autodetecting partitions</span></h4>
<p>The Linux loop driver actually supports partitions in loopback devices, but it is disabled by default.  To enable it, do the following:
</p>
<ul>
<li> Get rid of all your loopback devices (unmount all mounted images, etc.).
</li>
<li> Unload the loop <a href="/index.php/Kernel_modules" title="Kernel modules">module</a>.
</li>
</ul>
<pre># modprobe -r loop
</pre>
<ul>
<li> Load the loop <a href="/index.php/Kernel_modules" title="Kernel modules">module</a> with the <code style="display:inline-block; padding: 0.1em 0.3em;">max_part</code> parameter set.
</li>
</ul>
<pre># modprobe loop max_part=15
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>You can put an entry in <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/modprobe.d</code> to load the loop module with <code style="display:inline-block; padding: 0.1em 0.3em;">max_part=15</code> every time, or you can put <code style="display:inline-block; padding: 0.1em 0.3em;">loop.max_part=15</code> on the kernel command-line, depending on whether you have the <code style="display:inline-block; padding: 0.1em 0.3em;">loop.ko</code> module built into your kernel or not.</div>
<p>Set up your image as a loopback device:
</p>
<pre># losetup -f <i>disk_image</i>
</pre>
<p>Then, if the device created was <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/loop0</code>, additional devices <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/loop0pX</code> will have been automatically created, where X is the number of the partition.  These partition loopback devices can be mounted directly.  For example:
</p>
<pre># mount /dev/loop0p1 <i>mountpoint</i>
</pre>
<h4><span class="mw-headline" id="With_kpartx">With kpartx</span></h4>
<p><b>kpartx</b> from the <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/multipath-tools-git/">multipath-tools-git</a></span> package from the <a href="/index.php/Arch_User_Repository" title="Arch User Repository">AUR</a> can read a partition table on a device and create a new device for each partition.  For example:
</p>
<pre># kpartx -a /dev/loop0
</pre>
<h3><span class="mw-headline" id="Mounting_a_partition_inside_a_qcow2_image">Mounting a partition inside a qcow2 image</span></h3>
<p>You may mount a partition inside a qcow2 image using <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-nbd</code>. See <a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/QEMU/Images#Mounting_an_image_on_the_host">Wikibooks</a>.
</p>
<h3><span class="mw-headline" id="Using_any_real_partition_as_the_single_primary_partition_of_a_hard_disk_image">Using any real partition as the single primary partition of a hard disk image</span></h3>
<p>Sometimes, you may wish to use one of your system partitions from within QEMU. Using a raw partition for a virtual machine will improve performance, as the read and write operations do not go through the file system layer on the physical host. Such a partition also provides a way to share data between the host and guest.
</p><p>In Arch Linux, device files for raw partitions are, by default, owned by <i>root</i> and the <i>disk</i> group.  If you would like to have a non-root user be able to read and write to a raw partition, you need to change the owner of the partition's device file to that user.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;"><strong> Warning: </strong>
<ul>
<li> Although it is possible, it is not recommended to allow virtual machines to alter critical data on the host system, such as the root partition.
</li>
<li> You must not mount a file system on a partition read-write on both the host and the guest at the same time. Otherwise, data corruption will result.
</li>
</ul>
</div>
<p>After doing so, you can attach the partition to a QEMU virtual machine as a virtual disk.
</p><p>However, things are a little more complicated if you want to have the <i>entire</i> virtual machine contained in a partition.  In that case, there would be no disk image file to actually boot the virtual machine since you cannot install a bootloader to a partition that is itself formatted as a file system and not as a partitioned device with a MBR.  Such a virtual machine can be booted either by specifying the <a href="/index.php/Kernels" title="Kernels">kernel</a> and <a href="/index.php/Initramfs" title="Initramfs" class="mw-redirect">initrd</a> manually, or by simulating a disk with a MBR by using linear <a href="/index.php/RAID" title="RAID">RAID</a>.
</p>
<h4><span class="mw-headline" id="By_specifying_kernel_and_initrd_manually">By specifying kernel and initrd manually</span></h4>
<p>QEMU supports loading <a href="/index.php/Kernels" title="Kernels">Linux kernels</a> and <a href="/index.php/Initramfs" title="Initramfs" class="mw-redirect">init ramdisks</a> directly, thereby circumventing bootloaders such as <a href="/index.php/GRUB" title="GRUB">GRUB</a>.  It then can be launched with the physical partition containing the root file system as the virtual disk, which will not appear to be partitioned.  This is done by issuing a command similar to the following:
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>In this example, it is the <b>host's</b> images that are being used, not the guest's.  If you wish to use the guest's images, either mount <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/sda3</code> read-only (to protect the file system from the host) and specify the <code style="display:inline-block; padding: 0.1em 0.3em;">/full/path/to/images</code>  or use some kexec hackery in the guest to reload the guest's kernel (extends boot time). </div>
<pre>$ qemu-system-i386 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda /dev/sda3
</pre>
<p>In the above example, the physical partition being used for the guest's root file system is <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/sda3</code> on the host, but it shows up as <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/sda</code> on the guest.
</p><p>You may, of course, specify any kernel and initrd that you want, and not just the ones that come with Arch Linux.
</p>
<h4><span class="mw-headline" id="Simulate_virtual_disk_with_MBR_using_linear_RAID">Simulate virtual disk with MBR using linear RAID</span></h4>
<p>A more complicated way to have a virtual machine use a physical partition, while keeping that partition formatted as a file system and not just having the guest partition the partition as if it were a disk, is to simulate a MBR for it so that it can boot using a bootloader such as GRUB.
</p><p>You can do this using software <a href="/index.php/RAID" title="RAID">RAID</a> in linear mode (you need the <code style="display:inline-block; padding: 0.1em 0.3em;">linear.ko</code> kernel driver) and a loopback device: the trick is to dynamically prepend a master boot record (MBR) to the real partition you wish to embed in a QEMU raw disk image.
</p><p>Suppose you have a plain, unmounted <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/hdaN</code> partition with some file system on it you wish to make part of a QEMU disk image. First, you create some small file to hold the MBR:
</p>
<pre>$ dd if=/dev/zero of=<i>/path/to/mbr</i> count=32
</pre>
<p>Here, a 16 KB (32 * 512 bytes) file is created. It is important not to make it too small (even if the MBR only needs a single 512 bytes block), since the smaller it will be, the smaller the chunk size of the software RAID device will have to be, which could have an impact on performance. Then, you setup a loopback device to the MBR file:
</p>
<pre># losetup -f <i>/path/to/mbr</i>
</pre>
<p>Let us assume the resulting device is <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/loop0</code>, because we would not already have been using other loopbacks. Next step is to create the "merged" MBR + <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/hdaN</code> disk image using software RAID:
</p>
<pre># modprobe linear
# mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0 /dev/hda<i>N</i>
</pre>
<p>The resulting <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/md0</code> is what you will use as a QEMU raw disk image (do not forget to set the permissions so that the emulator can access it). The last (and somewhat tricky) step is to set the disk configuration (disk geometry and partitions table) so that the primary partition start point in the MBR matches the one of <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/hda<i>N</i></code> inside <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/md0</code> (an offset of exactly 16 * 512 = 16384 bytes in this example). Do this using <code style="display:inline-block; padding: 0.1em 0.3em;">fdisk</code> on the host machine, not in the emulator: the default raw disc detection routine from QEMU often results in non-kilobyte-roundable offsets (such as 31.5 KB, as in the previous section) that cannot be managed by the software RAID code. Hence, from the the host:
</p>
<pre># fdisk /dev/md0
</pre>
<p>Press <code style="display:inline-block; padding: 0.1em 0.3em;">X</code> to enter the expert menu. Set number of 's'ectors per track so that the size of one cylinder matches the size of your MBR file. For two heads and a sector size of 512, the number of sectors per track should be 16, so we get cylinders of size 2x16x512=16k.
</p><p>Now, press <code style="display:inline-block; padding: 0.1em 0.3em;">R</code> to return to the main menu. 
</p><p>Press <code style="display:inline-block; padding: 0.1em 0.3em;">P</code> and check that the cylinder size is now 16k.
</p><p>Now, create a single primary partition corresponding to <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/hda<i>N</i></code>. It should start at cylinder 2 and end at the end of the disk (note that the number of cylinders now differs from what it was when you entered fdisk.
</p><p>Finally, 'w'rite the result to the file: you are done. You now have a partition you can mount directly from your host, as well as part of a QEMU disk image: 
</p>
<pre>$ qemu-system-i386 -hdc /dev/md0 <i>[...]</i>
</pre>
<p>You can, of course, safely set any bootloader on this disk image using QEMU, provided the original <code style="display:inline-block; padding: 0.1em 0.3em;">/dev/hda<i>N</i></code> partition contains the necessary tools.
</p>
<h2><span class="mw-headline" id="Networking">Networking</span></h2>
<p>The performance of virtual networking should be better with tap devices and bridges than with user-mode networking or vde because tap devices and bridges are implemented in-kernel.
</p><p>In addition, networking performance can be improved by assigning virtual machines a <a rel="nofollow" class="external text" href="http://wiki.libvirt.org/page/Virtio">virtio</a> network device rather than the default emulation of an e1000 NIC. See <a href="#Installing_virtio_drivers">#Installing virtio drivers</a> for more information.
</p>
<h3><span class="mw-headline" id="Link-level_address_caveat">Link-level address caveat</span></h3>
<p>By giving the <code style="display:inline-block; padding: 0.1em 0.3em;">-net nic</code> argument to QEMU, it will, by default, assign a virtual machine a network interface with the link-level address <code style="display:inline-block; padding: 0.1em 0.3em;">52:54:00:12:34:56</code>. However, when using bridged networking with multiple virtual machines, it is essential that each virtual machine has a unique link-level (MAC) address on the virtual machine side of the tap device. Otherwise, the bridge will not work correctly, because it will receive packets from multiple sources that have the same link-level address. This problem occurs even if the tap devices themselves have unique link-level addresses because the source link-level address is not rewritten as packets pass through the tap device.
</p><p>Make sure that each virtual machine has a unique link-level address, but it should always start with <code style="display:inline-block; padding: 0.1em 0.3em;">52:54:</code>. Use the following option, replace <i>X</i> with arbitrary hexadecimal digit:
</p>
<pre>$ qemu-system-i386 -net nic,macaddr=52:54:<i>XX:XX:XX:XX</i> -net vde <i>disk_image</i>
</pre>
<p>Generating unique link-level addresses can be done in several ways:
</p><p>1. Manually specify unique link-level address for each NIC. The benefit is that the DHCP server will assign the same IP address each time the virtual machine is run, but it is unusable for large number of virtual machines.
</p><p>2. Generate random link-level address each time the virtual machine is run. Practically zero probability of collisions, but the downside is that the DHCP server will assign a different IP address each time. You can use the following command in a script to generate random link-level address in a <code style="display:inline-block; padding: 0.1em 0.3em;">macaddr</code> variable:
</p>
<pre>printf -v macaddr "52:54:%02x:%02x:%02x:%02x" $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
qemu-system-i386 -net nic,macaddr="$macaddr" -net vde <i>disk_image</i>
</pre>
<p>3. Use the following script <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-mac-hasher.py</code> to generate the link-level address from the virtual machine name using a hashing function. Given that the names of virtual machines are unique, this method combines the benefits of the aforementioned methods: it generates the same link-level address each time the script is run, yet it preserves the practically zero probability of collisions.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">qemu-mac-hasher.py</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
#!/usr/bin/env python

import sys
import zlib

if len(sys.argv) != 2:
    print(&quot;usage: %s &lt;VM Name&gt;&quot; % sys.argv[0])
    sys.exit(1)

crc = zlib.crc32(sys.argv[1].encode(&quot;utf-8&quot;)) &amp; 0xffffffff
crc = str(hex(crc))[2:]
print(&quot;52:54:%s%s:%s%s:%s%s:%s%s&quot; % tuple(crc))
</pre>
<p>In a script, you can use for example:
</p>
<pre>vm_name="<i>VM Name</i>"
qemu-system-i386 -name "$vm_name" -net nic,macaddr=$(qemu-mac-hasher.py "$vm_name") -net vde <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="User-mode_networking">User-mode networking</span></h3>
<p>By default, without any <code style="display:inline-block; padding: 0.1em 0.3em;">-netdev</code> arguments, QEMU will use user-mode networking with a built-in DHCP server.  Your virtual machines will be assigned an IP address when they run their DHCP client, and they will be able to access the physical host's network through IP masquerading done by QEMU.  This only works with the TCP and UDP protocols, so ICMP, including <code style="display:inline-block; padding: 0.1em 0.3em;">ping</code>, will not work.  
</p><p>This default configuration allows your virtual machines to easily access the Internet, provided that the host is connected to it, but the virtual machines will not be directly visible on the external network, nor will virtual machines be able to talk to each other if you start up more than one concurrently.
</p><p>QEMU's user-mode networking can offer more capabilities such as built-in TFTP or SMB servers, or attaching guests to VLANs so that they can talk to each other.  See the QEMU documentation on the <code style="display:inline-block; padding: 0.1em 0.3em;">-net user</code> flag for more details.
</p><p>However, user-mode networking has limitations in both utility and performance.  More advanced network configurations require the use of tap devices or other methods.
</p>
<h3><span class="mw-headline" id="Tap_networking_with_QEMU">Tap networking with QEMU</span></h3>
<p><a href="http://en.wikipedia.org/wiki/TUN/TAP" class="extiw" title="wikipedia:TUN/TAP">Tap devices</a> are a Linux kernel feature that allows you to create virtual network interfaces that appear as real network interfaces. Packets sent to a tap interface are delivered to a userspace program, such as QEMU, that has bound itself to the interface.
</p><p>QEMU can use tap networking for a virtual machine so that packets sent to the tap interface will be sent to the virtual machine and appear as coming from a network interface (usually an Ethernet interface) in the virtual machine.  Conversely, everything that the virtual machine sends through its network interface will appear on the tap interface.
</p><p>Tap devices are supported by the Linux bridge drivers, so it is possible to bridge together tap devices with each other and possibly with other host interfaces such as <code style="display:inline-block; padding: 0.1em 0.3em;">eth0</code>. This is desirable if you want your virtual machines to be able to talk to each other, or if you want other machines on your LAN to be able to talk to the virtual machines.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #FFDDDD; border: thin solid #DDBBBB; overflow: hidden;"><strong> Warning: </strong>If you bridge together tap device and some host interface, such as <code style="display:inline-block; padding: 0.1em 0.3em;">eth0</code>, your virtual machines will appear directly on the external network, which will expose them to possible attack. Depending on what resources your virtual machines have access to, you may need to take all the precautions you normally would take in securing a computer to secure your virtual machines. If the risk is too great, virtual machines have little resources or you set up multiple virtual machines, better solution might be to use <a href="#Host-only_networking">host-only networking</a> and set up NAT. In this case you only need one firewall on the host instead of multiple firewalls for each guest.</div>
<h4><span class="mw-headline" id="Host-only_networking">Host-only networking</span></h4>
<p>If the bridge is given an IP address and traffic destined for it is allowed, but no real interface (e.g. <code style="display:inline-block; padding: 0.1em 0.3em;">eth0</code>) is connected to the bridge, then the virtual machines will be able to talk to each other and the host system. However, they will not be able to talk to anything on the external network, provided that you do not set up IP masquerading on the physical host. This configuration is called <i>host-only networking</i> by other virtualization software such as <a href="/index.php/VirtualBox" title="VirtualBox">VirtualBox</a>.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>
<ul>
<li> If you want to set up IP masquerading, e.g. NAT for virtual machines, see the <a href="/index.php/Internet_sharing#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a> page.
</li>
<li> You may want to have a DHCP server running on the bridge interface to service the virtual network. For example, to use the <code style="display:inline-block; padding: 0.1em 0.3em;">172.20.0.1/16</code> subnet with <a href="/index.php/Dnsmasq" title="Dnsmasq">dnsmasq</a> as the DHCP server:
</li>
</ul>
<pre># ip addr add 172.20.0.1/16 dev br0
# ip link set br0 up
# dnsmasq --interface&#61;br0 --bind-interfaces --dhcp-range&#61;172.20.0.2,172.20.255.254
</pre>
</div>
<h4><span class="mw-headline" id="Internal_networking">Internal networking</span></h4>
<p>If you do not give the bridge an IP address and add an <a href="/index.php/Iptables" title="Iptables">iptables</a> rule to drop all traffic to the bridge in the INPUT chain, then the virtual machines will be able to talk to each other, but not to the physical host or to the outside network.  This configuration is called <i>internal networking</i> by other virtualization software such as <a href="/index.php/VirtualBox" title="VirtualBox">VirtualBox</a>. You will need to either assign static IP addresses to the virtual machines or run a DHCP server on one of them.
</p>
<h4><span class="mw-headline" id="Bridged_networking_using_qemu-bridge-helper">Bridged networking using qemu-bridge-helper</span></h4>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>This method is available since QEMU 1.1, see <a rel="nofollow" class="external free" href="http://wiki.qemu.org/Features/HelperNetworking">http://wiki.qemu.org/Features/HelperNetworking</a>.</div>
<p>This method does not require a start-up script and readily accommodates multiple taps and multiple bridges. It uses <code style="display:inline-block; padding: 0.1em 0.3em;">/usr/lib/qemu/qemu-bridge-helper</code> binary, which allows creating tap devices on an existing bridge.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>See <a href="/index.php/Bridge_with_netctl" title="Bridge with netctl">Bridge with netctl</a> for information on creating bridge.</div> 
<p>First, copy <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/qemu/bridge.conf.sample</code> to <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/qemu/bridge.conf</code>. Now modify <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/qemu/bridge.conf</code> to contain the names of all bridges to be used by QEMU: 
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu/bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
allow <i>bridge0</i>
allow <i>bridge1</i>
...</pre>
<p>Now start the VM. The most basic usage would be:
</p>
<pre>$ qemu-system-i386 -net nic -net bridge,br=<i>bridge0</i> <i>[...]</i>
</pre>
<p>With multiple taps, the most basic usage requires specifying the VLAN for all additional NICs:
</p>
<pre>$ qemu-system-i386 -net nic -net bridge,br=<i>bridge0</i> -net nic,vlan=1 -net bridge,vlan=1,br=<i>bridge1</i> <i>[...]</i>
</pre>
<h4><span class="mw-headline" id="Creating_bridge_manually">Creating bridge manually</span></h4>
<div style="text-align: center; margin-bottom: 1em; overflow:hidden;">
<table class="notice noprint toc" id="poorwriting" style="background: &#123;&#123;&#123;backgroundcolor}}}; border-color: &#123;&#123;&#123;bordercolor}}}; width: 100%">
<tr>
<td style="background-color: &#123;&#123;&#123;signalcolor}}}; width: 100px"> <a href="/index.php/File:Tango-mail-mark-junk.png" class="image"><img alt="Tango-mail-mark-junk.png" src="/images/e/e7/Tango-mail-mark-junk.png" width="48" height="48" /></a>
</td>
<td>  <b>This article or section is poorly written.</b> <div style="font-size: 90%"><b>Reason:</b> This section needs serious cleanup and may contain out-of-date information. (<a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:QEMU">Discuss</a>)</div>
</td>
<td style="background-color: &#123;&#123;&#123;signalcolor}}}; width: 100px"> <a href="/index.php/File:Tango-mail-mark-junk.png" class="image"><img alt="Tango-mail-mark-junk.png" src="/images/e/e7/Tango-mail-mark-junk.png" width="48" height="48" /></a>
</td></tr></table>
</div>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>Since QEMU 1.1, the <a rel="nofollow" class="external text" href="http://wiki.qemu.org/Features/HelperNetworking">network bridge helper</a> can set tun/tap up for you without the need for additional scripting. See <a href="#Bridged_networking_using_qemu-bridge-helper">#Bridged networking using qemu-bridge-helper</a>.</div>
<p>The following describes how to bridge a virtual machine to a host interface such as <code style="display:inline-block; padding: 0.1em 0.3em;">eth0</code>, which is probably the most common configuration. This configuration makes it appear that the virtual machine is located directly on the external network, on the same Ethernet segment as the physical host machine.
</p><p>We will replace the normal Ethernet adapter with a bridge adapter and bind the normal Ethernet adapter to it. See <a rel="nofollow" class="external free" href="http://en.gentoo-wiki.com/wiki/KVM#Networking_2">http://en.gentoo-wiki.com/wiki/KVM#Networking_2</a><sup>[<a href="http://en.wikipedia.org/wiki/Wikipedia:Link_rot" class="extiw" title="wikipedia:Wikipedia:Link rot">dead link</a> 2013-07-23]</sup>.
</p>
<ul>
<li> Install <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span>, which provides <code style="display:inline-block; padding: 0.1em 0.3em;">brctl</code> to manipulate bridges.
</li>
</ul>
<ul>
<li> Enable IPv4 forwarding:
</li>
</ul>
<pre># sysctl net.ipv4.ip_forward=1
</pre>
<p>To make the change permanent, change <code style="display:inline-block; padding: 0.1em 0.3em;">net.ipv4.ip_forward = 0</code> to <code style="display:inline-block; padding: 0.1em 0.3em;">net.ipv4.ip_forward = 1</code> in <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/sysctl.d/99-sysctl.conf</code>.
</p>
<ul>
<li> Load the <code style="display:inline-block; padding: 0.1em 0.3em;">tun</code> module and configure it to be loaded on boot. See <a href="/index.php/Kernel_modules" title="Kernel modules">Kernel modules</a> for details.
</li>
</ul>
<ul>
<li> Now create the bridge. See <a href="/index.php/Bridge_with_netctl" title="Bridge with netctl">Bridge with netctl</a> for details. Remember to name your bridge as <code style="display:inline-block; padding: 0.1em 0.3em;">br0</code>, or change the scripts below to your bridge's name.
</li>
</ul>
<ul>
<li> Create the script that QEMU uses to bring up the tap adapter with <code style="display:inline-block; padding: 0.1em 0.3em;">root:kvm</code> 750 permissions:
</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifup</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
#!/bin/sh
  
echo &quot;Executing /etc/qemu-ifup&quot;
echo &quot;Bringing up $1 for bridged mode...&quot;
sudo /usr/bin/ip link set $1 up promisc on
echo &quot;Adding $1 to br0...&quot;
sudo /usr/bin/brctl addif br0 $1
sleep 2
</pre>
<ul>
<li> Create the script that QEMU uses to bring down the tap adapter in <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/qemu-ifdown</code> with <code style="display:inline-block; padding: 0.1em 0.3em;">root:kvm</code> 750 permissions:
</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/qemu-ifdown</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
#!/bin/sh
 
echo &quot;Executing /etc/qemu-ifdown&quot;
sudo /usr/bin/ip link set $1 down
sudo /usr/bin/brctl delif br0 $1
sudo /usr/bin/ip link delete dev $1
</pre>
<ul>
<li> Use <code style="display:inline-block; padding: 0.1em 0.3em;">visudo</code> to add the following to your <code style="display:inline-block; padding: 0.1em 0.3em;">sudoers</code> file:
</li>
</ul>
<pre>
Cmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl
%kvm     ALL=NOPASSWD: QEMU
</pre>
<ul>
<li> You launch QEMU using the following <code style="display:inline-block; padding: 0.1em 0.3em;">run-qemu</code> script:
</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">run-qemu</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
#!/bin/bash
USERID=$(whoami)

# Get name of newly created TAP device; see https://bbs.archlinux.org/viewtopic.php?pid=1285079#p1285079
precreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
sudo /usr/bin/ip tuntap add user $USERID mode tap
postcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)
IFACE=$(comm -13 &lt;(echo &quot;$precreationg&quot;) &lt;(echo &quot;$postcreation&quot;))

# This line creates a random MAC address. The downside is the DHCP server will assign a different IP address each time
printf -v macaddr &quot;52:54:%02x:%02x:%02x:%02x&quot; $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff )) $(( $RANDOM &amp; 0xff)) $(( $RANDOM &amp; 0xff ))
# Instead, uncomment and edit this line to set a static MAC address. The benefit is that the DHCP server will assign the same IP address.
# macaddr='52:54:be:36:42:a9'
  
qemu-system-i386 -net nic,macaddr=$macaddr -net tap,ifname=&quot;$IFACE&quot; $*
  
sudo ip link set dev $IFACE down &amp;&gt; /dev/null
sudo ip tuntap del $IFACE mode tap &amp;&gt; /dev/null 
</pre>
<p>Then to launch a VM, do something like this
</p>
<pre>$ run-qemu -hda <i>myvm.img</i> -m 512 -vga std
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>If you cannot get a DHCP address in the host, it might be because <a href="/index.php/Iptables" title="Iptables">iptables</a> is up by default in the bridge.</div>
<ul>
<li> It is recommended for performance and security reasons to disable the firewall on the bridge:
</li>
</ul>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/sysctl.d/10-disable-firewall-on-bridge.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
net.bridge.bridge-nf-call-ip6tables = 0
net.bridge.bridge-nf-call-iptables = 0
net.bridge.bridge-nf-call-arptables = 0
</pre>
<p>Run <code style="display:inline-block; padding: 0.1em 0.3em;">sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf</code> to apply the changes immediately.
</p><p>See the <a rel="nofollow" class="external text" href="http://wiki.libvirt.org/page/Networking#Creating_network_initscripts">libvirt wiki</a> and <a rel="nofollow" class="external text" href="https://bugzilla.redhat.com/show_bug.cgi?id=512206">Fedora bug 512206</a>. If you get errors by sysctl during boot about non-existing files, make the <code style="display:inline-block; padding: 0.1em 0.3em;">bridge</code> module load at boot. See <a href="/index.php/Kernel_modules#Loading" title="Kernel modules">Kernel modules#Loading</a>.
</p><p>Alternatively, you can configure <a href="/index.php/Iptables" title="Iptables">iptables</a> to allow all traffic to be forwarded across the bridge by adding a rule like this:
</p>
<pre>-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT
</pre>
<h3><span class="mw-headline" id="Networking_with_VDE2">Networking with VDE2</span></h3>
<div style="text-align: center; margin-bottom: 1em; overflow:hidden;">
<table class="notice noprint toc" id="poorwriting" style="background: &#123;&#123;&#123;backgroundcolor}}}; border-color: &#123;&#123;&#123;bordercolor}}}; width: 100%">
<tr>
<td style="background-color: &#123;&#123;&#123;signalcolor}}}; width: 100px"> <a href="/index.php/File:Tango-mail-mark-junk.png" class="image"><img alt="Tango-mail-mark-junk.png" src="/images/e/e7/Tango-mail-mark-junk.png" width="48" height="48" /></a>
</td>
<td>  <b>This article or section is poorly written.</b> <div style="font-size: 90%"><b>Reason:</b> This section needs serious cleanup and may contain out-of-date information. (<a rel="nofollow" class="external text" href="https://wiki.archlinux.org/index.php/Talk:QEMU">Discuss</a>)</div>
</td>
<td style="background-color: &#123;&#123;&#123;signalcolor}}}; width: 100px"> <a href="/index.php/File:Tango-mail-mark-junk.png" class="image"><img alt="Tango-mail-mark-junk.png" src="/images/e/e7/Tango-mail-mark-junk.png" width="48" height="48" /></a>
</td></tr></table>
</div>
<h4><span class="mw-headline" id="What_is_VDE.3F">What is VDE?</span></h4>
<p>VDE stands for Virtual Distributed Ethernet. It started as an enhancement of <a href="/index.php/User-mode_Linux" title="User-mode Linux">uml</a>_switch. It is a toolbox to manage virtual networks.
</p><p>The idea is to create virtual switches, which are basically sockets, and to "plug" both physical and virtual machines in them. The configuration we show here is quite simple; However, VDE is much more powerful than this, it can plug virtual switches together, run them on different hosts and monitor the traffic in the switches. You are invited to read <a rel="nofollow" class="external text" href="http://wiki.virtualsquare.org/wiki/index.php/Main_Page">the documentation of the project</a>.
</p><p>The advantage of this method is you do not have to add sudo privileges to your users. Regular users should not be allowed to run modprobe.
</p>
<h4><span class="mw-headline" id="Basics">Basics</span></h4>
<p>VDE support can be <a href="/index.php/Pacman" title="Pacman">installed</a> via the <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=vde2">vde2</a></span> package in the <a href="/index.php/Official_repositories" title="Official repositories">official repositories</a>.
</p><p>In our config, we use tun/tap to create a virtual interface on my host. Load the <code style="display:inline-block; padding: 0.1em 0.3em;">tun</code> module (see <a href="/index.php/Kernel_modules" title="Kernel modules">Kernel modules</a> for details):
</p>
<pre># modprobe tun
</pre>
<p>Now create the virtual switch:
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
</pre>
<p>This line creates the switch, creates <code style="display:inline-block; padding: 0.1em 0.3em;">tap0</code>, "plugs" it, and allows the users of the group <code style="display:inline-block; padding: 0.1em 0.3em;">users</code> to use it.
</p><p>The interface is plugged in but not configured yet. To configure it, run this command:
</p>
<pre># ip addr add 192.168.100.254/24 dev tap0
</pre>
<p>Now, you just have to run KVM with these <code style="display:inline-block; padding: 0.1em 0.3em;">-net</code> options as a normal user:
</p>
<pre>$ qemu-system-i386 -net nic -net vde -hda <i>[...]</i>
</pre>
<p>Configure networking for your guest as you would do in a physical network.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>You might want to set up NAT on tap device to access the internet from the virtual machine. See <a href="/index.php/Internet_sharing#Enable_NAT" title="Internet sharing">Internet sharing#Enable NAT</a> for more information.</div>
<h4><span class="mw-headline" id="Startup_scripts">Startup scripts</span></h4>
<p>Example of main script starting VDE:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/scripts/qemu-network-env</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
#!/bin/sh
# QEMU/VDE network environment preparation script

# The IP configuration for the tap device that will be used for
# the virtual machine network:

TAP_DEV=tap0
TAP_IP=192.168.100.254
TAP_MASK=24
TAP_NETWORK=192.168.100.0

# Host interface
NIC=eth0

case &quot;$1&quot; in
  start)
        echo -n &quot;Starting VDE network for QEMU: &quot;

        # If you want tun kernel module to be loaded by script uncomment here 
	#modprobe tun 2&gt;/dev/null
	## Wait for the module to be loaded
 	#while ! lsmod | grep -q &quot;^tun&quot;; do echo &quot;Waiting for tun device&quot;; sleep 1; done

        # Start tap switch
        vde_switch -tap &quot;$TAP_DEV&quot; -daemon -mod 660 -group users

        # Bring tap interface up
        ip address add &quot;$TAP_IP&quot;/&quot;$TAP_MASK&quot; dev &quot;$TAP_DEV&quot;
        ip link set &quot;$TAP_DEV&quot; up

        # Start IP Forwarding
        echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -s &quot;$TAP_NETWORK&quot;/&quot;$TAP_MASK&quot; -o &quot;$NIC&quot; -j MASQUERADE
        ;;
  stop)
        echo -n &quot;Stopping VDE network for QEMU: &quot;
        # Delete the NAT rules
        iptables -t nat -D POSTROUTING &quot;$TAP_NETWORK&quot;/&quot;$TAP_MASK&quot; -o &quot;$NIC&quot; -j MASQUERADE

        # Bring tap interface down
        ip link set &quot;$TAP_DEV&quot; down

        # Kill VDE switch
        pgrep -f vde_switch | xargs kill -TERM 
        ;;
  restart|reload)
        $0 stop
        sleep 1
        $0 start
        ;;
  *)
        echo &quot;Usage: $0 {start|stop|restart|reload}&quot;
        exit 1
esac
exit 0
</pre>
<p>Example of systemd service using the above script:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu-network-env.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
[Unit]
Description=Manage VDE Switch

[Service]
Type=oneshot
ExecStart=/etc/systemd/scripts/qemu-network-env start
ExecStop=/etc/systemd/scripts/qemu-network-env stop
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</pre>
<p>Change permissions for <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-network-env</code> to be executable
</p>
<pre># chmod u+x /etc/systemd/scripts/qemu-network-env
</pre>
<p>You can start it as usual (see <a href="/index.php/Systemd#Using_units" title="Systemd">systemd#Using units</a> for details):
</p>
<pre># systemctl start qemu-network-env
</pre>
<h4><span class="mw-headline" id="Alternative_method">Alternative method</span></h4>
<p>If the above method does not work or you do not want to mess with kernel configs, TUN, dnsmasq, and iptables you can do the following for the same result.
</p>
<pre># vde_switch -daemon -mod 660 -group users
# slirpvde --dhcp --daemon
</pre>
<p>Then, to start the VM with a connection to the network of the host:
</p>
<pre>$ qemu-system-i386 -net nic,macaddr=52:54:00:00:EE:03 -net vde <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="VDE2_Bridge">VDE2 Bridge</span></h3>
<p>Based on <a rel="nofollow" class="external text" href="http://selamatpagicikgu.wordpress.com/2011/06/08/quickhowto-qemu-networking-using-vde-tuntap-and-bridge/">quickhowto: qemu networking using vde, tun/tap, and bridge</a> graphic. Any virtual machine connected to vde is externally exposed. For example, each virtual machine can receive DHCP configuration directly from your ADSL router.
</p>
<h4><span class="mw-headline" id="Basics_2">Basics</span></h4>
<p>Remember that you need <code style="display:inline-block; padding: 0.1em 0.3em;">tun</code> module and <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=bridge-utils">bridge-utils</a></span> package.
</p><p>Create the vde2/tap device:
</p>
<pre># vde_switch -tap tap0 -daemon -mod 660 -group users
# ip link set tap0 up
</pre>
<p>Create bridge:
</p>
<pre># brctl addbr br0
</pre>
<p>Add devices:
</p>
<pre># brctl addif br0 eth0
# brctl addif br0 tap0
</pre>
<p>And configure bridge interface:
</p>
<pre># dhcpcd br0
</pre>
<h4><span class="mw-headline" id="Startup_scripts_2">Startup scripts</span></h4>
<p>All devices must be set up. And only the bridge needs an IP address. For physical devices on the bridge (e.g. <code style="display:inline-block; padding: 0.1em 0.3em;">eth0</code>), this can be done with <a href="/index.php/Netctl" title="Netctl">netctl</a> using a custom Ethernet profile with:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/netctl/ethernet-noip</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
Description='A more versatile static Ethernet connection'
Interface=eth0
Connection=ethernet
IP=no
</pre>
<p>VDE2 tap interface can be activated with the <a href="/index.php/Systemd/Services#VDE2_interface" title="Systemd/Services">VDE2 interface custom systemd service</a>.
</p><p>And finally, you can create the <a href="/index.php/Bridge_with_netctl" title="Bridge with netctl">bridge interface with netctl</a>.
</p>
<h2><span class="mw-headline" id="Graphics">Graphics</span></h2>
<p>QEMU can use the following different graphic outputs: <code style="display:inline-block; padding: 0.1em 0.3em;">std</code>, <code style="display:inline-block; padding: 0.1em 0.3em;">cirrus</code>, <code style="display:inline-block; padding: 0.1em 0.3em;">vmware</code>, <code style="display:inline-block; padding: 0.1em 0.3em;">qxl</code>, and <code style="display:inline-block; padding: 0.1em 0.3em;">none</code>.
</p>
<h3><span class="mw-headline" id="std">std</span></h3>
<p>With <code style="display:inline-block; padding: 0.1em 0.3em;">-vga std</code> you can get a resolution of up to 2560 x 1600 pixels.
</p>
<h3><span class="mw-headline" id="vmware">vmware</span></h3>
<p>Although it is a bit buggy, it performs better than std and cirrus. On the guest, install the VMware drivers (<span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=xf86-video-vmware">xf86-video-vmware</a></span> and <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=xf86-input-vmmouse">xf86-input-vmmouse</a></span> for Arch Linux guests).
</p>
<h3><span class="mw-headline" id="qxl">qxl</span></h3>
<p>QXL is a paravirtual graphics driver with 2D support. To use it, these condition must be met:
</p>
<ul>
<li> <a href="#Spice_support">Spice</a> has to be enabled on the host system.
</li>
<li> A driver has to be installed on the guest (e.g. <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/xf86-video-qxl/">xf86-video-qxl</a></span> which is available in the <a href="/index.php/AUR" title="AUR" class="mw-redirect">AUR</a>).
</li>
<li> The virtual machine has to be started with <code style="display:inline-block; padding: 0.1em 0.3em;">-vga qxl</code> switch.
</li>
</ul>
<h3><span class="mw-headline" id="none">none</span></h3>
<p>This is like a PC that has no VGA card at all. You would not even be able to access it with the <code style="display:inline-block; padding: 0.1em 0.3em;">-vnc</code> option. Also, this is different from the <code style="display:inline-block; padding: 0.1em 0.3em;">-nographic</code> option which lets QEMU emulate a VGA card, but disables the SDL display.
</p>
<h3><span class="mw-headline" id="vnc">vnc</span></h3>
<p>Given that you used the <code style="display:inline-block; padding: 0.1em 0.3em;">-nographic</code> option, you can add the <code style="display:inline-block; padding: 0.1em 0.3em;">-vnc display</code> option to have QEMU listen on <code style="display:inline-block; padding: 0.1em 0.3em;">display</code> and redirect the VGA display to the VNC session. There is an example of this in the <a href="#Starting_QEMU_virtual_machines_on_boot">#Starting QEMU virtual machines on boot</a> section's example configs.
</p>
<pre>$ qemu-system-i386 -vga std -nographic -vnc&#160;:0
$ gvncviewer&#160;:0
</pre>
<p>When using VNC, you might experience keyboard problems described (in gory details) <a rel="nofollow" class="external text" href="https://www.berrange.com/posts/2010/07/04/more-than-you-or-i-ever-wanted-to-know-about-virtual-keyboard-handling/">here</a>. The solution is <i>not</i> to use the <code style="display:inline-block; padding: 0.1em 0.3em;">-k</code> option on QEMU, and to use <code style="display:inline-block; padding: 0.1em 0.3em;">gvncviewer</code> from <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=gtk-vnc">gtk-vnc</a></span>. See also <a rel="nofollow" class="external text" href="http://www.mail-archive.com/libvir-list@redhat.com/msg13340.html">this</a> message posted on libvirt's mailing list.
</p>
<h2><span class="mw-headline" id="Installing_virtio_drivers">Installing virtio drivers</span></h2>
<p>QEMU offers guests the ability to use paravirtualized block and network devices using the <a rel="nofollow" class="external text" href="http://wiki.libvirt.org/page/Virtio">virtio</a> drivers, which provide better performance and lower overhead.
</p>
<ul>
<li> A virtio block device requires the option <code style="display:inline-block; padding: 0.1em 0.3em;">-drive</code> instead of the simple <code style="display:inline-block; padding: 0.1em 0.3em;">-hd*</code> plus <code style="display:inline-block; padding: 0.1em 0.3em;">if=virtio</code>:
</li>
</ul>
<pre>$ qemu-system-i386 -boot order=c -drive file=<i>disk_image</i>,if=virtio
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong><code style="display:inline-block; padding: 0.1em 0.3em;">-boot order=c</code> is absolutely necessary when you want to boot from it. There is no auto-detection as with <code style="display:inline-block; padding: 0.1em 0.3em;">-hd*</code>.</div>
<ul>
<li> Almost the same goes for the network:
</li>
</ul>
<pre>$ qemu-system-i386 -net nic,model=virtio
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>This will only work if the guest machine has drivers for virtio devices. Linux does, and the required drivers are included in Arch Linux, but there is no guarantee that virtio devices will work with other operating systems.</div>
<h3><span class="mw-headline" id="Preparing_an_.28Arch.29_Linux_guest">Preparing an (Arch) Linux guest</span></h3>
<p>To use virtio devices after an Arch Linux guest has been installed, the following modules must be loaded in the guest: <code style="display:inline-block; padding: 0.1em 0.3em;">virtio</code>, <code style="display:inline-block; padding: 0.1em 0.3em;">virtio_pci</code>, <code style="display:inline-block; padding: 0.1em 0.3em;">virtio_blk</code>, <code style="display:inline-block; padding: 0.1em 0.3em;">virtio_net</code>, and <code style="display:inline-block; padding: 0.1em 0.3em;">virtio_ring</code>. For 32-bit guests, the specific "virtio" module is not necessary.
</p><p>If you want to boot from a virtio disk, the initial ramdisk must be <a href="/index.php/Mkinitcpio" title="Mkinitcpio">rebuilt</a>. Add the appropriate modules in <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/mkinitcpio.conf</code> like this:
</p>
<pre>MODULES="virtio_blk virtio_pci virtio_net"
</pre>
<p>and rebuild the initial ramdisk:
</p>
<pre># mkinitcpio -p linux
</pre>
<p>Virtio disks are recognized with the prefix <code style="display:inline-block; padding: 0.1em 0.3em;"><b>v</b></code> (e.g. <code style="display:inline-block; padding: 0.1em 0.3em;"><b>v</b>da</code>, <code style="display:inline-block; padding: 0.1em 0.3em;"><b>v</b>db</code>, etc.); therefore, changes must be made in at least <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/fstab</code> and <code style="display:inline-block; padding: 0.1em 0.3em;">/boot/grub/grub.cfg</code> when booting from a virtio disk.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>When referencing to disks by <a href="/index.php/Persistent_block_device_naming#By-uuid" title="Persistent block device naming">UUID</a> in both <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/fstab</code> and bootloader, nothing has to be done.</div>
<p>Further information on paravirtualization with KVM can be found <a rel="nofollow" class="external text" href="http://www.linux-kvm.org/page/Boot_from_virtio_block_device">here</a>.
</p>
<h3><span class="mw-headline" id="Preparing_a_Windows_guest">Preparing a Windows guest</span></h3>
<h4><span class="mw-headline" id="Block_device_drivers">Block device drivers</span></h4>
<p>Preparing a Windows guest for booting from virtio disk is a bit tricky.
</p><p>You can download the virtio disk driver from the <a rel="nofollow" class="external text" href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers">Fedora repository</a>.
</p><p>Now you need to create a new disk image, which fill force Windows to search for the driver. For example:
</p>
<pre>$ qemu-img create -f qcow2 <i>fake.qcow2</i> 1G
</pre>
<p>Run the original Windows guest (with the boot disk still in IDE mode) with the fake disk (in virtio mode) and a CD-ROM with the driver.
</p>
<pre>$ qemu-system-i386 -m 512 -vga std -drive file=<i>windows_disk_image</i>,if=ide -drive file=<i>fake.qcow2</i>,if=virtio -cdrom virtio-win-0.1-74.iso
</pre>
<p>Windows will detect the fake disk and try to find a driver for it. If it fails, go to the <i>Device Manager</i>, locate the SCSI drive with an exclamation mark icon (should be open), click <i>Update driver</i> and select the virtual CD-ROM. Do not forget to select the checkbox which says to search for directories recursively.
</p><p>When the installation is successful, you can turn off the virtual machine and launch it again, now with the boot disk attached in virtio mode:
</p>
<pre>$ qemu-system-i386 -m 512 -vga std -drive file=<i>windows_disk_image</i>,if=virtio
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>If you encounter the Blue Screen of Death, make sure you did not forget the <code style="display:inline-block; padding: 0.1em 0.3em;">-m</code> parameter, and that you do not boot with virtio instead of ide for the system drive before drivers are installed.</div>
<h4><span class="mw-headline" id="Network_drivers">Network drivers</span></h4>
<p>Installing virtio network drivers is a bit easier, simply add the <code style="display:inline-block; padding: 0.1em 0.3em;">-net</code> argument as explained above.
</p>
<pre>$ qemu-system-i386 -m 512 -vga std -drive file=<i>windows_disk_image</i>,if=virtio -net nic,model=virtio -cdrom virtio-win-0.1-74.iso
</pre>
<p>Windows will detect the network adapter and try to find a driver for it. If it fails, go to the <i>Device Manager</i>, locate the network adapter with an exclamation mark icon (should be open), click <i>Update driver</i> and select the virtual CD-ROM. Do not forget to select the checkbox which says to search for directories recursively.
</p>
<h3><span class="mw-headline" id="Preparing_a_FreeBSD_guest">Preparing a FreeBSD guest</span></h3>
<p>Install the <code style="display:inline-block; padding: 0.1em 0.3em;">emulators/virtio-kmod</code> port if you are using FreeBSD 8.3 or later up until 10.0-CURRENT where they are included into the kernel. After installation, add the following to your <code style="display:inline-block; padding: 0.1em 0.3em;">/boot/loader.conf</code> file:
</p>
<pre>
virtio_loader=&quot;YES&quot;
virtio_pci_load=&quot;YES&quot;
virtio_blk_load=&quot;YES&quot;
if_vtnet_load=&quot;YES&quot;
virtio_balloon_load=&quot;YES&quot;
</pre>
<p>Then modify your <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/fstab</code> by doing the following:
</p>
<pre>
sed -i/etc/fstab.bak &quot;s/ad/vtbd/g&quot; /etc/fstab
</pre>
<p>And verify that <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/fstab</code> is consistent. If anything goes wrong, just boot into a rescue CD and copy <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/fstab.bak</code> back to <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/fstab</code>.
</p>
<h2><span class="mw-headline" id="Tips_and_tricks">Tips and tricks</span></h2>
<h3><span class="mw-headline" id="Starting_QEMU_virtual_machines_on_boot">Starting QEMU virtual machines on boot</span></h3>
<h4><span class="mw-headline" id="With_libvirt">With libvirt</span></h4>
<p>If a virtual machine is set up with <a href="/index.php/Libvirt" title="Libvirt">libvirt</a>, it can be configured through the virt-manager GUI to start at host boot by going to the Boot Options for the virtual machine and selecting "Start virtual machine on host boot up".
</p>
<h4><span class="mw-headline" id="Custom_script">Custom script</span></h4>
<p>To run QEMU VMs on boot, you can use following systemd unit and config.
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/systemd/system/qemu@.service</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
[Unit]
Description=QEMU virtual machine

[Service]
Environment=&quot;type=system-x86_64&quot; &quot;haltcmd=kill -INT $MAINPID&quot;
EnvironmentFile=/etc/conf.d/qemu.d/%i
ExecStart=/usr/bin/env qemu-${type} -name %i -nographic $args
ExecStop=/bin/sh -c ${haltcmd}
TimeoutStopSec=30
KillMode=none

[Install]
WantedBy=multi-user.target
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>According to <code style="display:inline-block; padding: 0.1em 0.3em;">systemd.service(5)</code> and <code style="display:inline-block; padding: 0.1em 0.3em;">systemd.kill(5)</code> man pages it is necessary to use the <code style="display:inline-block; padding: 0.1em 0.3em;">KillMode=none</code> option. Otherwise the main qemu process will be killed immediately after the <code style="display:inline-block; padding: 0.1em 0.3em;">ExecStop</code> command quits (it simply echoes one string) and your quest system will not be able to shutdown correctly.</div>
<p>Then create per-VM configuration files, named <code style="display:inline-block; padding: 0.1em 0.3em;">/etc/conf.d/qemu.d/<i>vm_name</i></code>, with the following variables set:
</p>
<dl>
<dt> type
</dt>
<dd> QEMU binary to call. If specified, will be prepended with <code style="display:inline-block; padding: 0.1em 0.3em;">/usr/bin/qemu-</code> and that binary will be used to start the VM. I.e. you can boot e.g. <code style="display:inline-block; padding: 0.1em 0.3em;">qemu-system-arm</code> images with <code style="display:inline-block; padding: 0.1em 0.3em;">type="system-arm"</code>.
</dd>
<dt> args
</dt>
<dd> QEMU command line to start with. Will always be prepended with <code style="display:inline-block; padding: 0.1em 0.3em;">-name ${vm} -nographic</code>.
</dd>
<dt> haltcmd
</dt>
<dd> Command to shut down a VM safely. I am using <code style="display:inline-block; padding: 0.1em 0.3em;">-monitor telnet:..</code> and power off my VMs via ACPI by sending <code style="display:inline-block; padding: 0.1em 0.3em;">system_powerdown</code> to monitor. You can use SSH or some other ways.
</dd>
</dl>
<p>Example configs:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/one</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
type=&quot;system-x86_64&quot;

args=&quot;-enable-kvm -m 512 -hda /dev/mapper/vg0-vm1 -net nic,macaddr=DE:AD:BE:EF:E0:00 \
 -net tap,ifname=tap0 -serial telnet:localhost:7000,server,nowait,nodelay \
 -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0&quot;

haltcmd=&quot;echo 'system_powerdown' | nc localhost 7100&quot; # or netcat/ncat

# You can use other ways to shut down your VM correctly
#haltcmd=&quot;ssh powermanager@vm1 sudo poweroff&quot;
</pre>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/conf.d/qemu.d/two</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
args=&quot;-enable-kvm -m 512 -hda /srv/kvm/vm2.img -net nic,macaddr=DE:AD:BE:EF:E0:01 \
 -net tap,ifname=tap1 -serial telnet:localhost:7001,server,nowait,nodelay \
 -monitor telnet:localhost:7101,server,nowait,nodelay -vnc :1&quot;

haltcmd=&quot;echo 'system_powerdown' | nc localhost 7101&quot;
</pre>
<p>To set which virtual machines will start on boot-up, use
</p>
<pre># systemctl enable qemu@<i>vm_name</i>
# systemctl disable qemu@<i>vm_name</i>
</pre>
<h3><span class="mw-headline" id="Mouse_integration">Mouse integration</span></h3>
<p>To prevent the mouse from being grabbed when clicking on the guest operating system's window, add the option <code style="display:inline-block; padding: 0.1em 0.3em;">-usbdevice tablet</code>. This means QEMU is able to report the mouse position without having to grab the mouse. This also overrides PS/2 mouse emulation when activated. For example:
</p>
<pre>$ qemu-system-i386 -hda <i>disk_image</i> -m 512 -vga std -usbdevice tablet
</pre>
<h3><span class="mw-headline" id="Pass-through_host_USB_device">Pass-through host USB device</span></h3>
<p>To access physical USB device connected to host from VM, you can start QEMU with following option:
</p>
<pre>$ qemu-system-i386 -usbdevice host:<i>vendor_id</i>:<i>product_id</i> <i>disk_image</i>
</pre>
<p>You can find <code style="display:inline-block; padding: 0.1em 0.3em;">vendor_id</code> and <code style="display:inline-block; padding: 0.1em 0.3em;">product_id</code> of your device with <code style="display:inline-block; padding: 0.1em 0.3em;">lsusb</code> command.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDDDFF; border: thin solid #BBBBDD; overflow: hidden;"><strong> Note: </strong>If you encounter permission errors when running QEMU, see <a href="/index.php/Udev#Writing_udev_rules" title="Udev">Udev#Writing udev rules</a> for information on how to set permissions of the device.</div>
<h3><span class="mw-headline" id="Enabling_KSM">Enabling KSM</span></h3>
<p>Kernel Samepage Merging (KSM) is a feature of the Linux kernel that allows for an application to register with the kernel to have its pages merged with other processes that also register to have their pages merged. The KSM mechanism allows for guest virtual machines to share pages with each other. In an environment where many of the guest operating systems are similar, this can result in significant memory savings.
</p><p>To enable KSM, simply run
</p>
<pre># echo 1 &gt; /sys/kernel/mm/ksm/run
</pre>
<p>To make it permanent, you can use <a href="/index.php/Systemd#Temporary_files" title="Systemd">systemd's temporary files</a>:
</p>
<pre style="margin-bottom: 0; border-bottom:none; padding-bottom:0.8em;">/etc/tmpfiles.d/ksm.conf</pre>
<pre style="margin-top: 0; border-top-style:dashed; padding-top: 0.8em;">
w /sys/kernel/mm/ksm/run - - - - 1
</pre>
<p>If KSM is running, and there are pages to be merged (i.e. at least two similar VMs are running), then <code style="display:inline-block; padding: 0.1em 0.3em;">/sys/kernel/mm/ksm/pages_shared</code> should be non-zero. See <a rel="nofollow" class="external free" href="https://www.kernel.org/doc/Documentation/vm/ksm.txt">https://www.kernel.org/doc/Documentation/vm/ksm.txt</a> for more information.
</p>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>An easy way to see how well KSM is performing is to simply print the contents of all the files in that directory: <pre>$ grep . /sys/kernel/mm/ksm/*</pre></div>
<h3><span class="mw-headline" id="Spice_support">Spice support</span></h3>
<p>The <a rel="nofollow" class="external text" href="http://spice-space.org/">Spice project</a> aims to provide a complete, open-source solution for interaction with virtualized desktop devices. Its main focus is to provide high-quality remote access to QEMU virtual machines.
</p><p>The official <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=qemu">qemu</a></span> package is built with Spice support.
</p><p>You can start your VM:
</p>
<pre>$ qemu-system-i386 -vga qxl -spice port=5930,disable-ticketing
</pre>
<p>Then connect with the the spice client
</p>
<pre>$ spicec -h 127.0.0.1 -p 5930
</pre>
<div style="padding: 5px; margin: 0.50em 0; background-color: #DDFFDD; border: thin solid #BBDDBB; overflow: hidden;"><strong> Tip: </strong>
<ul>
<li> Spice guest drivers can be downloaded <a rel="nofollow" class="external text" href="http://www.spice-space.org/download.html">here</a> in the <i>Guest</i> section.
</li>
<li> The key combination to escape mouse and keyboard grab can be configured, the default is <code style="display:inline-block; padding: 0.1em 0.3em;">Shift+F12</code>: <pre>$ spicec --hotkeys release-cursor=ctrl+alt</pre>
</li>
<li> <span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://www.archlinux.org/packages/?name=virt-manager">virt-manager</a></span> has a Spice client built in.
</li>
</ul>
</div>
<h3><span class="mw-headline" id="Copy_and_paste">Copy and paste</span></h3>
<p>To have copy and paste between the host and the guest you need to enable the spice agent communication channel. It requires to add a virtio-serial device to the guest, and open a port for the spice vdagent. It is also required to install the spice vdagent in guest (<span style="font-family: monospace"><a rel="nofollow" class="external text" href="https://aur.archlinux.org/packages/spice-vdagent/">spice-vdagent</a></span> for Arch guests, <a rel="nofollow" class="external text" href="http://www.spice-space.org/download.html">Windows guest tools</a> for Windows guests). Make sure the agent is running (and for future, started automatically).
</p><p>Start QEMU with the following options:
</p>
<pre>$ qemu-system-i386 -vga qxl -spice port=5930,disable-ticketing -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
</pre>
<p>The <code style="display:inline-block; padding: 0.1em 0.3em;">-device virtio-serial-pci</code> option adds the virtio-serial device, <code style="display:inline-block; padding: 0.1em 0.3em;">-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0</code> opens a port for spice vdagent in that device and <code style="display:inline-block; padding: 0.1em 0.3em;">-chardev spicevmc,id=spicechannel0,name=vdagent</code> adds a spicevmc chardev for that port.
</p><p>It is important that the <code style="display:inline-block; padding: 0.1em 0.3em;">chardev=</code> option of the <code style="display:inline-block; padding: 0.1em 0.3em;">virtserialport</code> device matches the <code style="display:inline-block; padding: 0.1em 0.3em;">id=</code> option given to the <code style="display:inline-block; padding: 0.1em 0.3em;">chardev</code> option (<code style="display:inline-block; padding: 0.1em 0.3em;">spicechannel0</code> in this example). It is also important that the port name is <code style="display:inline-block; padding: 0.1em 0.3em;">com.redhat.spice.0</code>, because that is the namespace where vdagent is looking for in the guest. And finally, specify <code style="display:inline-block; padding: 0.1em 0.3em;">name=vdagent</code> so that spice knows what this channel is for.
</p>
<h3><span class="mw-headline" id="Windows-specific_notes">Windows-specific notes</span></h3>
<p>QEMU can run any version of Windows from Windows 95 through Windows 8.
</p><p>It is possible to run <a href="/index.php/Windows_PE" title="Windows PE">Windows PE</a> in QEMU.
</p>
<h4><span class="mw-headline" id="Remote_Desktop_Protocol">Remote Desktop Protocol</span></h4>
<p>If you use a MS Windows guest, you might want to use RDP to connect to your guest VM. If you are using a VLAN or are not in the same network as the guest, use:
</p>
<pre>$ qemu-system-i386 -nographic -net user,hostfwd=tcp::5555-:3389
</pre>
<p>Then connect with either rdesktop or freerdp to the guest. For example:
</p>
<pre>$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan
</pre>
<h2><span class="mw-headline" id="Troubleshooting">Troubleshooting</span></h2>
<h3><span class="mw-headline" id="Mouse_cursor_is_jittery_or_erratic">Mouse cursor is jittery or erratic</span></h3>
<p>If the cursor jumps around the screen uncontrollably, entering this on the terminal before starting QEMU might help:
</p>
<pre>$ export SDL_VIDEO_X11_DGAMOUSE=0
</pre>
<p>If this helps, you can add this to your <code style="display:inline-block; padding: 0.1em 0.3em;">bashrc</code> file.
</p>
<h3><span class="mw-headline" id="Keyboard_seems_broken_or_the_arrow_keys_do_not_work">Keyboard seems broken or the arrow keys do not work</span></h3>
<p>Should you find that some of your keys do not work or "press" the wrong key (in particular, the arrow keys), you likely need to specify your keyboard layout as an option. The keyboard layouts can be found in <code style="display:inline-block; padding: 0.1em 0.3em;">/usr/share/qemu/keymaps</code>.
</p>
<pre>$ qemu-system-i386 -k <i>keymap</i> <i>disk_image</i>
</pre>
<h3><span class="mw-headline" id="Virtual_machine_runs_too_slowly">Virtual machine runs too slowly</span></h3>
<p>There are a number of techniques that you can use to improve the performance if your virtual machine.  For example:
</p>
<ul>
<li> Use the <code style="display:inline-block; padding: 0.1em 0.3em;">-cpu host</code> option to make QEMU emulate the host's exact CPU.  If you do not do this, it may be trying to emulate a more generic CPU.
</li>
<li> If the host machine has multiple CPUs, assign the guest more CPUs using the <code style="display:inline-block; padding: 0.1em 0.3em;">-smp</code> option.
</li>
<li> Make sure you have assigned the virtual machine enough memory.  By default, QEMU only assigns 128 MiB of memory to each virtual machine.  Use the <code style="display:inline-block; padding: 0.1em 0.3em;">-m</code> option to assign more memory.  For example, <code style="display:inline-block; padding: 0.1em 0.3em;">-m 1024</code> runs a virtual machine with 1024 MiB of memory.
</li>
<li> Use KVM if possible: add <code style="display:inline-block; padding: 0.1em 0.3em;">-machine type=pc,accel=kvm</code> to the QEMU start command you use.
</li>
<li> If supported by drivers in the guest operating system, use <a rel="nofollow" class="external text" href="http://wiki.libvirt.org/page/Virtio">virtio</a> for network and/or block devices.  For example:
</li>
</ul>
<pre>$ qemu-system-i386 -net nic,model=virtio -net tap,if=tap0,script=no -drive file=<i>disk_image</i>,media=disk,if=virtio
</pre>
<ul>
<li> Use TAP devices instead of user-mode networking. See <a href="#Tap_networking_with_QEMU">#Tap networking with QEMU</a>.
</li>
<li> If the guest OS is doing heavy writing to its disk, you may benefit from certain mount options on the host's file system.  For example, you can mount an <a href="/index.php/Ext4" title="Ext4">ext4 file system</a> with the option <code style="display:inline-block; padding: 0.1em 0.3em;">barrier=0</code>.  You should read the documentation for any options that you change because sometimes performance-enhancing options for file systems come at the cost of data integrity.
</li>
<li> If you have a raw disk image, disable the cache:
</li>
</ul>
<pre>$ qemu-system-i386 -drive file=<i>disk_image</i>,if=virtio,cache=none
</pre>
<ul>
<li> If you are running multiple virtual machines concurrently that all have the same operating system installed, you can save memory by enabling <a href="http://en.wikipedia.org/wiki/Kernel_SamePage_Merging_(KSM)" class="extiw" title="wikipedia:Kernel SamePage Merging (KSM)">kernel same-page merging</a>:
</li>
</ul>
<pre># echo 1 &gt; /sys/kernel/mm/ksm/run
</pre>
<ul>
<li> In some cases, memory can be reclaimed from running virtual machines by running a memory ballooning driver in the guest operating system and launching QEMU with the <code style="display:inline-block; padding: 0.1em 0.3em;">-balloon virtio</code> option.
</li>
</ul>
<p>See <a rel="nofollow" class="external free" href="http://www.linux-kvm.org/page/Tuning_KVM">http://www.linux-kvm.org/page/Tuning_KVM</a> for more information.
</p>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<ul>
<li> <a rel="nofollow" class="external text" href="http://qemu.org">Official QEMU website</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://www.linux-kvm.org">Official KVM website</a>
</li>
<li> <a rel="nofollow" class="external text" href="http://qemu.weilnetz.de/qemu-doc.html">QEMU Emulator User Documentation</a>
</li>
<li> <a rel="nofollow" class="external text" href="https://en.wikibooks.org/wiki/QEMU">QEMU Wikibook</a>
</li>
<li> <i><a rel="nofollow" class="external text" href="http://alien.slackbook.org/dokuwiki/doku.php?id=slackware:qemu">Hardware virtualization with QEMU</a></i> by AlienBOB
</li>
<li> <i><a rel="nofollow" class="external text" href="http://blog.falconindy.com/articles/build-a-virtual-army.html">Building a Virtual Army</a></i> by Falconindy
</li>
<li> <i><a rel="nofollow" class="external text" href="http://qemu-buch.de/de/index.php/QEMU-KVM-Book/_Content">QEMU, KVM, Xen &amp; libvirt</a></i> by Robert Warnke and Thomas Ritzau
</li>
</ul>

<!-- 
NewPP limit report
CPU time usage: 0.423 seconds
Real time usage: 0.437 seconds
Preprocessor visited node count: 3024/1000000
Preprocessor generated node count: 6328/1000000
Postexpand include size: 65529/2097152 bytes
Template argument size: 35007/2097152 bytes
Highest expansion depth: 8/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key archwiki:pcache:idhash:1173-0!*!0!!en!2!* and timestamp 20140327133331
 -->
</div><div class="printfooter">
Retrieved from "<a href="https://wiki.archlinux.org/index.php?title=QEMU&amp;oldid=307115">https://wiki.archlinux.org/index.php?title=QEMU&amp;oldid=307115</a>"</div>
		<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/index.php/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="/index.php/Category:Emulators" title="Category:Emulators">Emulators</a></li><li><a href="/index.php/Category:Virtualization" title="Category:Virtualization">Virtualization</a></li></ul></div></div>		<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
<div id="column-one">
	<h2>Navigation menu</h2>
	<div id="p-cactions" class="portlet" role="navigation">
		<h3>Views</h3>
		<div class="pBody">
			<ul>
				<li id="ca-nstab-main" class="selected"><a href="/index.php/QEMU" title="View the content page [c]" accesskey="c">Page</a></li>
				<li id="ca-talk"><a href="/index.php/Talk:QEMU" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				<li id="ca-viewsource"><a href="/index.php?title=QEMU&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				<li id="ca-history"><a href="/index.php?title=QEMU&amp;action=history" rel="archives" title="Past revisions of this page [h]" accesskey="h">History</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal" role="navigation">
		<h3>Personal tools</h3>
		<div class="pBody">
			<ul>
				<li id="pt-createaccount"><a href="/index.php?title=Special:UserLogin&amp;returnto=QEMU&amp;type=signup">Create account</a></li>
				<li id="pt-login"><a href="/index.php?title=Special:UserLogin&amp;returnto=QEMU" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo" role="banner">
<a href="/index.php/Main_page" style="background-image: url(/skins/archlinux/archlogo.png);" title="Visit the main page"></a>
	</div>
	<div class="generated-sidebar portlet" id="p-navigation" role="navigation">
		<h3>Navigation</h3>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/index.php/Main_page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-categories"><a href="/index.php/Table_of_contents">Categories</a></li>
				<li id="n-portal"><a href="/index.php/Getting_involved" title="Various ways Archers can contribute to the community">Getting involved</a></li>
				<li id="n-currentevents"><a href="/index.php/ArchWiki:News" title="The latest lowdown on the wiki">Wiki news</a></li>
				<li id="n-randompage"><a href="/index.php/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet" role="search">
		<h3><label for="searchInput">Search</label></h3>
		<div id="searchBody" class="pBody">
			<form action="/index.php" id="searchform">
				<input type='hidden' name="title" value="Special:Search"/>
				<input type="search" name="search" placeholder="Search" title="Search ArchWiki [f]" accesskey="f" id="searchInput" />
				<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />&#160;
				<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />
			</form>
		</div>
	</div>
	<div class="generated-sidebar portlet" id="p-interaction" role="navigation">
		<h3>interaction</h3>
		<div class='pBody'>
			<ul>
				<li id="n-help"><a href="/index.php/Help:Contents" title="Wiki navigation, reading, and editing help">Help</a></li>
				<li id="n-Contributing"><a href="/index.php/ArchWiki:Contributing">Contributing</a></li>
				<li id="n-recentchanges"><a href="/index.php/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-Recent-talks"><a href="https://wiki.archlinux.org/index.php/Special:RecentChanges?namespace=0&amp;invert=1" rel="nofollow">Recent talks</a></li>
				<li id="n-newpages"><a href="/index.php/Special:NewPages">New pages</a></li>
				<li id="n-Reports"><a href="/index.php/ArchWiki:Reports">Reports</a></li>
				<li id="n-Requests"><a href="/index.php/ArchWiki:Requests">Requests</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb" role="navigation">
		<h3>Tools</h3>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/index.php/Special:WhatLinksHere/QEMU" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/index.php/Special:RecentChangesLinked/QEMU" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
				<li id="t-specialpages"><a href="/index.php/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/index.php?title=QEMU&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
				<li id="t-permalink"><a href="/index.php?title=QEMU&amp;oldid=307115" title="Permanent link to this revision of the page">Permanent link</a></li>
				<li id="t-info"><a href="/index.php?title=QEMU&amp;action=info">Page information</a></li>
			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet" role="navigation">
		<h3>In other languages</h3>
		<div class="pBody">
			<ul>
				<li class="interwiki-de"><a href="https://wiki.archlinux.de/title/Qemu" title="Qemu  Deutsch" lang="de" hreflang="de">Deutsch</a></li>
				<li class="interwiki-es"><a href="https://wiki.archlinux.org/index.php/QEMU_(Espa%C3%B1ol)" title="QEMU  espaol" lang="es" hreflang="es">Espaol</a></li>
				<li class="interwiki-fr"><a href="http://wiki.archlinux.fr/Qemu" title="Qemu  franais" lang="fr" hreflang="fr">Franais</a></li>
				<li class="interwiki-zh-cn"><a href="https://wiki.archlinux.org/index.php/QEMU_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" title="QEMU  " lang="zh-CN" hreflang="zh-CN"></a></li>
			</ul>
		</div>
	</div>
</div><!-- end of the left (by default at least) column -->
<div class="visualClear"></div>
<div id="footer" role="contentinfo">
	<ul id="f-list">
		<li id="lastmod"> This page was last modified on 26 March 2014, at 17:36.</li>
		<li id="copyright">Content is available under <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 or later</a> unless otherwise noted.</li>
		<li id="privacy"><a href="/index.php/ArchWiki:Privacy_policy" title="ArchWiki:Privacy policy">Privacy policy</a></li>
		<li id="about"><a href="/index.php/ArchWiki:About" title="ArchWiki:About">About ArchWiki</a></li>
		<li id="disclaimer"><a href="/index.php/ArchWiki:General_disclaimer" title="ArchWiki:General disclaimer">Disclaimers</a></li>
	</ul>
</div>
</div>
<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.489 secs. --></body><!-- Cached/compressed 20140327133332 -->
</html>