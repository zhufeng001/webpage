
<html>
<head>
<title>virt-v2v</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" href="pod.css" type="text/css" />
</head>
<body>


<ul id="index">
  <li><a href="#name">NAME</a></li>
  <li><a href="#synopsis">SYNOPSIS</a></li>
  <li><a href="#description">DESCRIPTION</a></li>
  <li><a href="#input-and-output-modes">INPUT AND OUTPUT MODES</a></li>
  <li><a href="#examples">EXAMPLES</a>
    <ul>
      <li><a href="#convert-from-vmware-vcenter-server-to-local-libvirt">Convert from VMware vCenter server to local libvirt</a></li>
      <li><a href="#convert-from-esx-to-rhev-m-ovirt">Convert from ESX to RHEV-M/oVirt</a></li>
      <li><a href="#convert-disk-image-to-openstack-glance">Convert disk image to OpenStack glance</a></li>
      <li><a href="#convert-disk-image-to-disk-image">Convert disk image to disk image</a></li>
    </ul>
  </li>
  <li><a href="#support-matrix">SUPPORT MATRIX</a>
    <ul>
      <li><a href="#hypervisors-input">Hypervisors (Input)</a></li>
      <li><a href="#hypervisors-output">Hypervisors (Output)</a></li>
      <li><a href="#virtualization-management-systems-output">Virtualization management systems (Output)</a></li>
      <li><a href="#guests">Guests</a></li>
    </ul>
  </li>
  <li><a href="#options">OPTIONS</a></li>
  <li><a href="#xen-paravirtualized-guests">XEN PARAVIRTUALIZED GUESTS</a></li>
  <li><a href="#enabling-virtio">ENABLING VIRTIO</a></li>
  <li><a href="#networks-and-bridges">NETWORKS AND BRIDGES</a></li>
  <li><a href="#input-from-vmware-vcenter-server">INPUT FROM VMWARE VCENTER SERVER</a>
    <ul>
      <li><a href="#esx:-remove-vmware-tools-from-windows-guests">ESX: REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</a></li>
      <li><a href="#esx:-vcenter-uri">ESX: VCENTER URI</a></li>
      <li><a href="#esx:-test-libvirt-connection-to-vcenter">ESX: TEST LIBVIRT CONNECTION TO VCENTER</a></li>
      <li><a href="#esx:-importing-a-guest">ESX: IMPORTING A GUEST</a></li>
    </ul>
  </li>
  <li><a href="#input-from-rhel-5-xen">INPUT FROM RHEL 5 XEN</a>
    <ul>
      <li><a href="#xen:-set-up-ssh-agent-access-to-xen-host">XEN: SET UP SSH-AGENT ACCESS TO XEN HOST</a></li>
      <li><a href="#xen:-test-libvirt-connection-to-remote-xen-host">XEN: TEST LIBVIRT CONNECTION TO REMOTE XEN HOST</a></li>
      <li><a href="#xen:-importing-a-guest">XEN: IMPORTING A GUEST</a></li>
    </ul>
  </li>
  <li><a href="#output-to-libvirt">OUTPUT TO LIBVIRT</a></li>
  <li><a href="#output-to-rhev">OUTPUT TO RHEV</a></li>
  <li><a href="#resource-requirements">RESOURCE REQUIREMENTS</a>
    <ul>
      <li><a href="#network">Network</a></li>
      <li><a href="#disk-space">Disk space</a></li>
      <li><a href="#vmware-vcenter-resources">VMware vCenter resources</a></li>
      <li><a href="#compute-power-and-ram">Compute power and RAM</a></li>
    </ul>
  </li>
  <li><a href="#post-conversion-tasks">POST-CONVERSION TASKS</a>
    <ul>
      <li><a href="#guest-network-configuration">Guest network configuration</a></li>
      <li><a href="#converting-a-windows-guest">Converting a Windows guest</a></li>
      <li><a href="#windows-recovery-console">Windows Recovery Console</a></li>
    </ul>
  </li>
  <li><a href="#free-space-for-conversion">FREE SPACE FOR CONVERSION</a></li>
  <li><a href="#running-virt-v2v-as-root-or-non-root">RUNNING VIRT-V2V AS ROOT OR NON-ROOT</a></li>
  <li><a href="#debugging-rhev-m-import-failures">DEBUGGING RHEV-M IMPORT FAILURES</a></li>
  <li><a href="#minimal-xml-for--i-libvirtxml-option">MINIMAL XML FOR -i libvirtxml OPTION</a></li>
  <li><a href="#machine-readable-output">MACHINE READABLE OUTPUT</a></li>
  <li><a href="#files">FILES</a></li>
  <li><a href="#environment-variables">ENVIRONMENT VARIABLES</a></li>
  <li><a href="#see-also">SEE ALSO</a></li>
  <li><a href="#authors">AUTHORS</a></li>
  <li><a href="#copyright">COPYRIGHT</a></li>
  <li><a href="#license">LICENSE</a></li>
  <li><a href="#bugs">BUGS</a></li>
</ul>

<h1 id="name">NAME</h1>

<p>virt-v2v - Convert a guest to use KVM</p>

<h1 id="synopsis">SYNOPSIS</h1>

<pre><code> virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi esx_guest

 virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi esx_guest \
   -o rhev -os rhev.nfs:/export_domain --network rhevm

 virt-v2v -i libvirtxml guest-domain.xml -o local -os /var/tmp

 virt-v2v -i disk disk.img -o local -os /var/tmp

 virt-v2v -i disk disk.img -o glance</code></pre>

<h1 id="description">DESCRIPTION</h1>

<p>Virt-v2v converts guests from a foreign hypervisor to run on KVM, managed by libvirt, OpenStack, oVirt, Red Hat Enterprise Virtualisation (RHEV) or several other targets. It can currently convert Red Hat Enterprise Linux and Windows guests running on Xen and VMware ESX.</p>

<p>There is also a companion front-end called <a href="virt-p2v.1.html">virt-p2v(1)</a> which comes as an ISO or CD image that can be booted on physical machines.</p>

<p>This manual page documents the rewritten virt-v2v included in libguestfs &ge; 1.28.</p>

<h1 id="input-and-output-modes">INPUT AND OUTPUT MODES</h1>

<pre><code>                         &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;  &#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o null
 -i disk &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;    &#x2502;            &#x2502; &#x2500;&#x2518;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o local
 -i ova  &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510; &#x2514;&#x2500;&#x2500;&#x25B6; &#x2502; virt-v2v   &#x2502; &#x2500;&#x2500;&#x2518;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o qemu
                  &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; &#x2502; conversion &#x2502; &#x2500;&#x2500;&#x2500;&#x2518;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;
 ESX &#x2500;&#x2500;&#x25B6;&#x250C;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2510;   &#x2502; server     &#x2502; &#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o libvirt &#x2502;&#x2500;&#x25B6; KVM
 Xen &#x2500;&#x2500;&#x25B6;&#x2502; -i libvirt &#x2500;&#x2500;&#x25B6; &#x2502;            &#x2502;     &#x2502;  (default) &#x2502;
 ... &#x2500;&#x2500;&#x25B6;&#x2502;  (default) &#x2502;   &#x2502;            &#x2502; &#x2500;&#x2500;&#x2510; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;
        &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518;   &#x2502;            &#x2502; &#x2500;&#x2510;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o glance
 -i libvirtxml &#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; &#x2502;            &#x2502; &#x2510;&#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o rhev
                         &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2518; &#x2514;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x2500;&#x25B6; -o vdsm</code></pre>

<p>Virt-v2v has a number of possible input and output modes, selected using the <i>-i</i> and <i>-o</i> options. Only one input and output mode can be selected for each run of virt-v2v.</p>

<p><i>-i libvirt</i> is used for reading from any libvirt source. Since libvirt can connect to many different hypervisors, it is used for reading guests from VMware ESX, RHEL 5 Xen and more. The <i>-ic</i> option selects the precise libvirt source.</p>

<p><i>-i disk</i> is used for reading from local disk images (mainly for testing).</p>

<p><i>-i ova</i> is used for reading from a VMware ova source file.</p>

<p><i>-i libvirtxml</i> is used to read from libvirt XML files. This is the method used by <a href="virt-p2v.1.html">virt-p2v(1)</a> behind the scenes.</p>

<p><i>-o glance</i> is used for writing to OpenStack Glance.</p>

<p><i>-o libvirt</i> is used for writing to any libvirt target. Libvirt can connect to local or remote KVM hypervisors. The <i>-oc</i> option selects the precise libvirt target.</p>

<p><i>-o local</i> is used to write to a local disk image with a local libvirt configuration file (mainly for testing).</p>

<p><i>-o qemu</i> writes to a local disk image with a shell script for booting the guest directly in qemu (mainly for testing).</p>

<p><i>-o rhev</i> is used to write to a RHEV-M / oVirt target. <i>-o vdsm</i> is only used when virt-v2v runs under VDSM control.</p>

<h1 id="examples">EXAMPLES</h1>

<h2 id="convert-from-vmware-vcenter-server-to-local-libvirt">Convert from VMware vCenter server to local libvirt</h2>

<p>You have a VMware vCenter server called <code>vcenter.example.com</code>, a datacenter called <code>Datacenter</code>, and an ESXi hypervisor called <code>esxi</code>. You want to convert a guest called <code>esx_guest</code> to run locally under libvirt.</p>

<pre><code> virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi esx_guest</code></pre>

<p>In this case you will most likely have to run virt-v2v as <code>root</code>, since it needs to talk to the system libvirt daemon and copy the guest disks to <code>/var/lib/libvirt/images</code>.</p>

<p>For more information see <a href="#input-from-vmware-vcenter-server">&quot;INPUT FROM VMWARE VCENTER SERVER&quot;</a> below.</p>

<h2 id="convert-from-esx-to-rhev-m-ovirt">Convert from ESX to RHEV-M/oVirt</h2>

<p>This is the same as the previous example, except you want to send the guest to a RHEV-M Export Storage Domain which is located remotely (over NFS) at <code>rhev.nfs:/export_domain</code>. If you are unclear about the location of the Export Storage Domain you should check the settings on your RHEV-M management console. Guest network interface(s) are connected to the target network called <code>rhevm</code>.</p>

<pre><code> virt-v2v -ic vpx://vcenter.example.com/Datacenter/esxi esx_guest \
   -o rhev -os rhev.nfs:/export_domain --network rhevm</code></pre>

<p>In this case the host running virt-v2v acts as a <b>conversion server</b>.</p>

<p>Note that after conversion, the guest will appear in the RHEV-M Export Storage Domain, from where you will need to import it using the RHEV-M user interface. (See <a href="#output-to-rhev">&quot;OUTPUT TO RHEV&quot;</a>).</p>

<h2 id="convert-disk-image-to-openstack-glance">Convert disk image to OpenStack glance</h2>

<p>Given a disk image from another hypervisor that you want to convert to run on OpenStack (only KVM-based OpenStack is supported), you can do:</p>

<pre><code> virt-v2v -i disk disk.img -o glance</code></pre>

<p>To control the name of the image in Glance, use the <i>-on</i> option.</p>

<h2 id="convert-disk-image-to-disk-image">Convert disk image to disk image</h2>

<p>Given a disk image from another hypervisor that you want to convert to run on KVM, you have two options. The simplest way is to try:</p>

<pre><code> virt-v2v -i disk disk.img -o local -os /var/tmp</code></pre>

<p>where virt-v2v guesses everything about the input <code>disk.img</code> and (in this case) writes the converted result to <code>/var/tmp</code>.</p>

<p>A more complex method is to write some <a href="http://libvirt.org/formatdomain.html">libvirt XML</a> describing the input guest (if you can get the source hypervisor to provide you with libvirt XML, then so much the better). You can then do:</p>

<pre><code> virt-v2v -i libvirtxml guest-domain.xml -o local -os /var/tmp</code></pre>

<p>Since <code>guest-domain.xml</code> contains the path(s) to the guest disk image(s) you do not need to specify the name of the disk image on the command line.</p>

<p>To convert a local disk image and immediately boot it in local qemu, do:</p>

<pre><code> virt-v2v -i disk disk.img -o qemu -os /var/tmp --qemu-boot</code></pre>

<h1 id="support-matrix">SUPPORT MATRIX</h1>

<h2 id="hypervisors-input">Hypervisors (Input)</h2>

<dl>

<dt>VMware ESXi</dt>
<dd>

<p>Must be managed by VMware vCenter. Unmanaged, direct input from ESXi is not supported.</p>

</dd>
<dt>OVA exported from VMware</dt>
<dd>

<p>OVAs from other hypervisors will not work.</p>

</dd>
<dt>RHEL 5 Xen</dt>
<dd>

</dd>
<dt>Citrix Xen</dt>
<dd>

<p>Citrix Xen has not been recently tested.</p>

</dd>
<dt>Hyper-V</dt>
<dd>

<p>Not recently tested. Requires that you export the disk or use <a href="virt-p2v.1.html">virt-p2v(1)</a> on Hyper-V.</p>

</dd>
<dt>Direct from disk images</dt>
<dd>

<p>Only disk images exported from supported hypervisors, and using container formats supported by qemu.</p>

</dd>
<dt>Physical machines</dt>
<dd>

<p>Using the <a href="virt-p2v.1.html">virt-p2v(1)</a> tool.</p>

</dd>
</dl>

<h2 id="hypervisors-output">Hypervisors (Output)</h2>

<p>QEMU and KVM only.</p>

<h2 id="virtualization-management-systems-output">Virtualization management systems (Output)</h2>

<dl>

<dt>OpenStack Glance</dt>
<dd>

</dd>
<dt>Red Hat Enterprise Virtualization (RHEV) 2.2 and up</dt>
<dd>

</dd>
<dt>Local libvirt</dt>
<dd>

<p>And hence <a href="http://man.he.net/man1/virsh">virsh(1)</a>, <a href="virt-manager.1.html">virt-manager(1)</a>, and similar tools.</p>

</dd>
<dt>Local disk</dt>
<dd>

</dd>
</dl>

<h2 id="guests">Guests</h2>

<dl>

<dt>Red Hat Enterprise Linux 3, 4, 5, 6, 7</dt>
<dd>

</dd>
<dt>CentOS 3, 4, 5, 6, 7</dt>
<dd>

</dd>
<dt>Scientific Linux 3, 4, 5, 6, 7</dt>
<dd>

</dd>
<dt>Fedora</dt>
<dd>

</dd>
<dt>SLES 10 and up</dt>
<dd>

</dd>
<dt>OpenSUSE 10 and up</dt>
<dd>

</dd>
<dt>Windows XP to Windows 7 / Windows Server 2008 R2</dt>
<dd>

<p>We use Windows internal version numbers, see <a href="https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions">https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions</a></p>

<p>Currently only NT 5.2 to NT 6.1 are supported, with support for later versions planned soon.</p>

<p>The Windows Recovery Console is not supported, see <a href="#windows-recovery-console">&quot;Windows Recovery Console&quot;</a> below.</p>

</dd>
</dl>

<h1 id="options">OPTIONS</h1>

<dl>

<dt><b>--help</b></dt>
<dd>

<p>Display help.</p>

</dd>
<dt><b>-b</b> ...</dt>
<dd>

</dd>
<dt><b>--bridge</b> ...</dt>
<dd>

<p>See <i>--network</i> below.</p>

</dd>
<dt><b>--debug-gc</b></dt>
<dd>

<p>Debug garbage collection and memory allocation. This is only useful when debugging memory problems in virt-v2v or the OCaml libguestfs bindings.</p>

</dd>
<dt><b>--debug-overlays</b></dt>
<dd>

<p>Save the overlay file(s) created during conversion. This option is only used for debugging virt-v2v and may be removed in a future version.</p>

</dd>
<dt><b>-i disk</b></dt>
<dd>

<p>Set the input method to <i>disk</i>.</p>

<p>In this mode you can read a virtual machine disk image with no metadata. virt-v2v tries to guess the best default metadata. This is usually adequate but you can get finer control (eg. of memory and vCPUs) by using <i>-i libvirtxml</i> instead. Only guests that use a single disk can be imported this way.</p>

</dd>
<dt><b>-i libvirt</b></dt>
<dd>

<p>Set the input method to <i>libvirt</i>. This is the default.</p>

<p>In this mode you have to specify a libvirt guest name or UUID on the command line. You may also specify a libvirt connection URI (see <i>-ic</i>).</p>

</dd>
<dt><b>-i libvirtxml</b></dt>
<dd>

<p>Set the input method to <i>libvirtxml</i>.</p>

<p>In this mode you have to pass a libvirt XML file on the command line. This file is read in order to get metadata about the source guest (such as its name, amount of memory), and also to locate the input disks. See <a href="#minimal-xml-for--i-libvirtxml-option">&quot;MINIMAL XML FOR -i libvirtxml OPTION&quot;</a> below.</p>

</dd>
<dt><b>-i local</b></dt>
<dd>

<p>This is the same as <i>-i disk</i>.</p>

</dd>
<dt><b>-i ova</b></dt>
<dd>

<p>Set the input method to <i>ova</i>.</p>

<p>In this mode you can read a VMware ova file. Virt-v2v will read the ova manifest file and check the vmdk volumes for validity (checksums) as well as analyzing the ovf file, and then convert the guest.</p>

</dd>
<dt><b>-ic</b> libvirtURI</dt>
<dd>

<p>Specify a libvirt connection URI to use when reading the guest. This is only used when <span style="white-space: nowrap;"><i>-i libvirt</i></span>.</p>

<p>Only local libvirt connections, ESX connections, or RHEL 5 Xen remote connections can be used. Other remote libvirt connections will not work in general.</p>

<p>See also <a href="#input-from-vmware-vcenter-server">&quot;INPUT FROM VMWARE VCENTER SERVER&quot;</a>, <a href="#input-from-rhel-5-xen">&quot;INPUT FROM RHEL 5 XEN&quot;</a> below.</p>

</dd>
<dt><b>-if</b> format</dt>
<dd>

<p>For <i>-i disk</i> only, this specifies the format of the input disk image. For other input methods you should specify the input format in the metadata.</p>

</dd>
<dt><b>--machine-readable</b></dt>
<dd>

<p>This option is used to make the output more machine friendly when being parsed by other programs. See <a href="#machine-readable-output">&quot;MACHINE READABLE OUTPUT&quot;</a> below.</p>

</dd>
<dt><b>-n</b> in:out</dt>
<dd>

</dd>
<dt><b>-n</b> out</dt>
<dd>

</dd>
<dt><b>--network</b> in:out</dt>
<dd>

</dd>
<dt><b>--network</b> out</dt>
<dd>

</dd>
<dt><b>-b</b> in:out</dt>
<dd>

</dd>
<dt><b>-b</b> out</dt>
<dd>

</dd>
<dt><b>--bridge</b> in:out</dt>
<dd>

</dd>
<dt><b>--bridge</b> out</dt>
<dd>

<p>Map network (or bridge) called <code>in</code> to network (or bridge) called <code>out</code>. If no <code>in:</code> prefix is given, all other networks (or bridges) are mapped to <code>out</code>.</p>

<p>See <a href="#networks-and-bridges">&quot;NETWORKS AND BRIDGES&quot;</a> below.</p>

</dd>
<dt><b>--no-copy</b></dt>
<dd>

<p>Don&#39;t copy the disks. Instead, conversion is performed (and thrown away), and metadata is written, but no disks are created. See also discussion of <span style="white-space: nowrap;"><i>-o null</i></span> below.</p>

<p>This is useful in two cases: Either you want to test if conversion is likely to succeed, without the long copying process. Or you are only interested in looking at the metadata.</p>

<p>This option is not compatible with <i>-o libvirt</i> since it would create a faulty guest (one with no disks).</p>

<p>This option is not compatible with <i>-o glance</i> for technical reasons.</p>

</dd>
<dt><b>--no-trim all</b></dt>
<dd>

</dd>
<dt><b>--no-trim</b> mp[,mp...]</dt>
<dd>

<p>By default virt-v2v runs <a href="http://man.he.net/man8/fstrim">fstrim(8)</a> to reduce the amount of data that needs to be copied. This is known to break some buggy bootloaders causing boot failures after conversion (see for example <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1141145#c27">https://bugzilla.redhat.com/show_bug.cgi?id=1141145#c27</a>).</p>

<p>You can use <i>--no-trim all</i> to disable all trimming. Note this will greatly increase the amount of data that has to be copied and can make virt-v2v run much more slowly.</p>

<p>You can also disable trimming on selected filesystems only (specified by a comma-separated list of their mount point(s) in the guest). Typically you would use <i>--no-trim /boot</i> to work around the grub bug mentioned above.</p>

<p>You can also disable trimming on partitions using the libguestfs naming scheme for devices, eg: <i>--no-trim /dev/sdb2</i> means do not trim the second partition on the second block device. Use <a href="virt-filesystems.1.html">virt-filesystems(1)</a> to list filesystem names in a guest.</p>

</dd>
<dt><b>-o disk</b></dt>
<dd>

<p>This is the same as <i>-o local</i>.</p>

</dd>
<dt><b>-o glance</b></dt>
<dd>

<p>Set the output method to OpenStack Glance. In this mode the converted guest is uploaded to Glance. You can control the image name by setting the <i>-on</i> option.</p>

</dd>
<dt><b>-o libvirt</b></dt>
<dd>

<p>Set the output method to <i>libvirt</i>. This is the default.</p>

<p>In this mode, the converted guest is created as a libvirt guest. You may also specify a libvirt connection URI (see <i>-oc</i>).</p>

<p>See <a href="#output-to-libvirt">&quot;OUTPUT TO LIBVIRT&quot;</a> below.</p>

</dd>
<dt><b>-o local</b></dt>
<dd>

<p>Set the output method to <i>local</i>.</p>

<p>In this mode, the converted guest is written to a local directory specified by <i>-os /dir</i> (the directory must exist). The converted guest&#39;s disks are written as:</p>

<pre><code> /dir/name-sda
 /dir/name-sdb
 [etc]</code></pre>

<p>and a libvirt XML file is created containing guest metadata:</p>

<pre><code> /dir/name.xml</code></pre>

<p>where <code>name</code> is the guest name.</p>

</dd>
<dt><b>-o null</b></dt>
<dd>

<p>Set the output method to <i>null</i>.</p>

<p>The guest is converted and copied (unless you also specify <i>--no-copy</i>), but the results are thrown away and no metadata is written.</p>

</dd>
<dt><b>-o ovirt</b></dt>
<dd>

<p>This is the same as <i>-o rhev</i>.</p>

</dd>
<dt><b>-o qemu</b></dt>
<dd>

<p>Set the output method to <i>qemu</i>.</p>

<p>This is similar to <i>-o local</i>, except that a shell script is written which you can use to boot the guest in qemu. The converted disks and shell script are written to the directory specified by <i>-os</i>.</p>

<p>When using this output mode, you can also specify the <i>--qemu-boot</i> option which boots the guest under qemu immediately.</p>

</dd>
<dt><b>-o rhev</b></dt>
<dd>

<p>Set the output method to <i>rhev</i>.</p>

<p>The converted guest is written to a RHEV Export Storage Domain. The <i>-os</i> parameter must also be used to specify the location of the Export Storage Domain. Note this does not actually import the guest into RHEV. You have to do that manually later using the UI.</p>

<p>See <a href="#output-to-rhev">&quot;OUTPUT TO RHEV&quot;</a> below.</p>

</dd>
<dt><b>-o vdsm</b></dt>
<dd>

<p>Set the output method to <i>vdsm</i>.</p>

<p>This mode is similar to <i>-o rhev</i> but is only used by RHEV VDSM when it runs virt-v2v under VDSM control.</p>

</dd>
<dt><b>-oa sparse</b></dt>
<dd>

</dd>
<dt><b>-oa preallocated</b></dt>
<dd>

<p>Set the output file allocation mode. The default is <code>sparse</code>.</p>

</dd>
<dt><b>-oc</b> libvirtURI</dt>
<dd>

<p>Specify a libvirt connection to use when writing the converted guest. This is only used when <span style="white-space: nowrap;"><i>-o libvirt</i></span>. See <a href="#output-to-libvirt">&quot;OUTPUT TO LIBVIRT&quot;</a> below.</p>

<p>Only local libvirt connections can be used. Remote libvirt connections will not work.</p>

</dd>
<dt><b>-of</b> format</dt>
<dd>

<p>When converting the guest, convert the disks to the given format.</p>

<p>If not specified, then the input format is used.</p>

</dd>
<dt><b>-on</b> name</dt>
<dd>

<p>Rename the guest when converting it. If this option is not used then the output name is the same as the input name.</p>

</dd>
<dt><b>-os</b> storage</dt>
<dd>

<p>The location of the storage for the converted guest.</p>

<p>For <i>-o libvirt</i>, this is a libvirt directory pool (see <span style="white-space: nowrap;"><code>virsh pool-list</code></span>) or pool UUID.</p>

<p>For <i>-o local</i> and <i>-o qemu</i>, this is a directory name. The directory must exist.</p>

<p>For <i>-o rhev</i>, this can be an NFS path of the Export Storage Domain of the form <code>&lt;host&gt;:&lt;path&gt;</code>, eg:</p>

<pre><code> rhev-storage.example.com:/rhev/export</code></pre>

<p>The NFS export must be mountable and writable by the user and host running virt-v2v, since the virt-v2v program has to actually mount it when it runs. So you probably have to run virt-v2v as <code>root</code>.</p>

<p><b>Or:</b> You can mount the Export Storage Domain yourself, and point <i>-os</i> to the mountpoint. Note that virt-v2v will still need to write to this remote directory, so virt-v2v will still need to run as <code>root</code>.</p>

<p>You will get an error if virt-v2v is unable to mount/write to the Export Storage Domain.</p>

</dd>
<dt><b>--password-file</b> file</dt>
<dd>

<p>Instead of asking for password(s) interactively, pass the password through a file. Note the file should contain the whole password, <b>without any trailing newline</b>, and for security the file should have mode <code>0600</code> so that others cannot read it.</p>

</dd>
<dt><b>--print-source</b></dt>
<dd>

<p>Print information about the source guest and stop. This option is useful when you are setting up network and bridge maps. See <a href="#networks-and-bridges">&quot;NETWORKS AND BRIDGES&quot;</a>.</p>

</dd>
<dt><b>--qemu-boot</b></dt>
<dd>

<p>When using <i>-o qemu</i> only, this boots the guest immediately after virt-v2v finishes.</p>

</dd>
<dt><b>-q</b></dt>
<dd>

</dd>
<dt><b>--quiet</b></dt>
<dd>

<p>This disables progress bars and other unnecessary output.</p>

</dd>
<dt><b>--root ask</b></dt>
<dd>

</dd>
<dt><b>--root single</b></dt>
<dd>

</dd>
<dt><b>--root first</b></dt>
<dd>

</dd>
<dt><b>--root</b> /dev/sdX</dt>
<dd>

</dd>
<dt><b>--root</b> /dev/VG/LV</dt>
<dd>

<p>Choose the root filesystem to be converted.</p>

<p>In the case where the virtual machine is dual-boot or multi-boot, or where the VM has other filesystems that look like operating systems, this option can be used to select the root filesystem (a.k.a. <code>C:</code> drive or <code>/</code>) of the operating system that is to be converted. The Windows Recovery Console, certain attached DVD drives, and bugs in libguestfs inspection heuristics, can make a guest look like a multi-boot operating system.</p>

<p>The default in virt-v2v &le; 0.7.1 was <span style="white-space: nowrap;"><i>--root single</i></span>, which causes virt-v2v to die if a multi-boot operating system is found.</p>

<p>Since virt-v2v &ge; 0.7.2 the default is now <span style="white-space: nowrap;"><i>--root ask</i></span>: If the VM is found to be multi-boot, then virt-v2v will stop and list the possible root filesystems and ask the user which to use. This requires that virt-v2v is run interactively.</p>

<p><span style="white-space: nowrap;"><i>--root first</i></span> means to choose the first root device in the case of a multi-boot operating system. Since this is a heuristic, it may sometimes choose the wrong one.</p>

<p>You can also name a specific root device, eg. <span style="white-space: nowrap;"><i>--root /dev/sda2</i></span> would mean to use the second partition on the first hard drive. If the named root device does not exist or was not detected as a root device, then virt-v2v will fail.</p>

<p>Note that there is a bug in grub which prevents it from successfully booting a multiboot system if VirtIO is enabled. Grub is only able to boot an operating system from the first VirtIO disk. Specifically, <code>/boot</code> must be on the first VirtIO disk, and it cannot chainload an OS which is not in the first VirtIO disk.</p>

</dd>
<dt><b>--vdsm-image-uuid</b> UUID</dt>
<dd>

</dd>
<dt><b>--vdsm-vol-uuid</b> UUID</dt>
<dd>

</dd>
<dt><b>--vdsm-vm-uuid</b> UUID</dt>
<dd>

<p>Normally the RHEV output mode chooses random UUIDs for the target guest. However VDSM needs to control the UUIDs and passes these parameters when virt-v2v runs under VDSM control. The parameters control:</p>

<ul>

<li><p>the image directory of each guest disk (<i>--vdsm-image-uuid</i>) (this option is passed once for each guest disk)</p>

</li>
<li><p>UUIDs for each guest disk (<i>--vdsm-vol-uuid</i>) (this option is passed once for each guest disk)</p>

</li>
<li><p>the VM and OVF file (<i>--vdsm-vm-uuid</i>).</p>

</li>
</ul>

<p>The format of UUIDs is: <code>12345678-1234-1234-1234-123456789abc</code> (each hex digit can be <code>0-9</code> or <code>a-f</code>), conforming to <span style="white-space: nowrap;">OSF DCE 1.1</span>.</p>

<p>These options can only be used with <i>-o vdsm</i>.</p>

</dd>
<dt><b>-v</b></dt>
<dd>

</dd>
<dt><b>--verbose</b></dt>
<dd>

<p>Enable verbose messages for debugging.</p>

</dd>
<dt><b>-V</b></dt>
<dd>

</dd>
<dt><b>--version</b></dt>
<dd>

<p>Display version number and exit.</p>

</dd>
<dt><b>--vmtype desktop</b></dt>
<dd>

</dd>
<dt><b>--vmtype server</b></dt>
<dd>

<p>For the <i>-o rhev</i> or <i>-o vdsm</i> targets only, specify the type of guest. You can set this to <code>desktop</code> or <code>server</code>. If the option is not given, then a suitable default is chosen based on the detected guest operating system.</p>

</dd>
<dt><b>-x</b></dt>
<dd>

<p>Enable tracing of libguestfs API calls.</p>

</dd>
</dl>

<h1 id="xen-paravirtualized-guests">XEN PARAVIRTUALIZED GUESTS</h1>

<p>Older versions of virt-v2v could turn a Xen paravirtualized (PV) guest into a KVM guest by installing a new kernel. This version of virt-v2v does <i>not</i> attempt to install any new kernels. Instead it will give you an error if there are <i>only</i> Xen PV kernels available.</p>

<p>Therefore before conversion you should check that a regular kernel is installed. For some older Linux distributions, this means installing a kernel from the table below:</p>

<pre><code> RHEL 3         (Does not apply, as there was no Xen PV kernel)
 
 RHEL 4         i686 with &gt; 10GB of RAM: install &#39;kernel-hugemem&#39;
                i686 SMP: install &#39;kernel-smp&#39;
                other i686: install &#39;kernel&#39;
                x86-64 SMP with &gt; 8 CPUs: install &#39;kernel-largesmp&#39;
                x86-64 SMP: install &#39;kernel-smp&#39;
                other x86-64: install &#39;kernel&#39;
 
 RHEL 5         i686: install &#39;kernel-PAE&#39;
                x86-64: install &#39;kernel&#39;
 
 SLES 10        i586 with &gt; 10GB of RAM: install &#39;kernel-bigsmp&#39;
                i586 SMP: install &#39;kernel-smp&#39;
                other i586: install &#39;kernel-default&#39;
                x86-64 SMP: install &#39;kernel-smp&#39;
                other x86-64: install &#39;kernel-default&#39;
 
 SLES 11+       i586: install &#39;kernel-pae&#39;
                x86-64: install &#39;kernel-default&#39;

 Windows        (Does not apply, as there is no Xen PV Windows kernel)</code></pre>

<h1 id="enabling-virtio">ENABLING VIRTIO</h1>

<p>&quot;Virtio&quot; is the name for a set of drivers which make disk (block device), network and other guest operations work much faster on KVM.</p>

<p>Older versions of virt-v2v could install these drivers for certain Linux guests. This version of virt-v2v does <i>not</i> attempt to install new Linux kernels or drivers, but will warn you if they are not installed already.</p>

<p>In order to enable virtio, and hence improve performance of the guest after conversion, you should ensure that the <b>minimum</b> versions of packages are installed <i>before</i> conversion, by consulting the table below.</p>

<pre><code> RHEL 3         No virtio drivers are available
 
 RHEL 4         kernel &gt;= 2.5.9-89.EL
 
 RHEL 5         kernel &gt;= 2.6.18-128.el5
                lvm2 &gt;= 2.02.40-6.el5
                selinux-policy-targeted &gt;= 2.4.6-203.el5
 
 RHEL 6+        All versions support virtio
 
 Fedora         All versions support virtio
 
 SLES 11+       All versions support virtio
 
 SLES 10        kernel &gt;= 2.6.16.60-0.85.1
 
 OpenSUSE 11+   All versions support virtio
 
 OpenSUSE 10    kernel &gt;= 2.6.25.5-1.1

 Windows        Drivers are installed from /usr/share/virtio-win
                if present</code></pre>

<h1 id="networks-and-bridges">NETWORKS AND BRIDGES</h1>

<p>Guests are usually connected to one or more networks, and when converted to the target hypervisor you usually want to reconnect those networks at the destination. The options <i>--network</i> and <i>--bridge</i> allow you to do that.</p>

<p>If you are unsure of what networks and bridges are in use on the source hypervisor, then you can examine the source metadata (libvirt XML, vCenter information, etc.). Or you can run virt-v2v with the <i>--print-source</i> option which causes virt-v2v to print out the information it has about the guest on the source and then exit.</p>

<p>In the <i>--print-source</i> output you will see a section showing the guest&#39;s Network Interface Cards (NICs):</p>

<pre><code> $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Network &quot;default&quot; mac: 52:54:00:d0:cf:0e</code></pre>

<p>This is typical of a libvirt guest: It has a single network interface connected to a network called <code>default</code>.</p>

<p>To map a specific network to a target network, for example <code>default</code> on the source to <code>rhevm</code> on the target, use:</p>

<pre><code> virt-v2v [...] --network default:rhevm</code></pre>

<p>To map every network to a target network, use:</p>

<pre><code> virt-v2v [...] --network rhevm</code></pre>

<p>Bridges are handled in the same way, but you have to use the <i>--bridge</i> option instead. For example:</p>

<pre><code> $ virt-v2v [-i ...] --print-source name
 [...]
 NICs:
     Bridge &quot;br0&quot;
 
 $ virt-v2v [...] --bridge br0:targetbr</code></pre>

<h1 id="input-from-vmware-vcenter-server">INPUT FROM VMWARE VCENTER SERVER</h1>

<p>Virt-v2v is able to import guests from VMware vCenter Server.</p>

<p>Note that virt-v2v <b>cannot</b> import guests directly from an ESXi hypervisor.</p>

<p>Virt-v2v uses libvirt for access to vCenter, and therefore the input mode should be <i>-i libvirt</i>. As this is the default, you don&#39;t need to specify it on the command line.</p>

<h2 id="esx:-remove-vmware-tools-from-windows-guests">ESX: REMOVE VMWARE TOOLS FROM WINDOWS GUESTS</h2>

<p>For Windows guests, you should remove VMware tools before conversion. Although this is not strictly necessary, and the guest will still be able to run, if you don&#39;t do this then the converted guest will complain on every boot. The tools cannot be removed after conversion because the uninstaller checks if it is running on VMware and refuses to start (which is also the reason that virt-v2v cannot remove them).</p>

<p>This is not necessary for Linux guests, as virt-v2v is able to remove VMware tools.</p>

<h2 id="esx:-vcenter-uri">ESX: VCENTER URI</h2>

<p>The libvirt URI of a vCenter server looks something like this:</p>

<pre><code> vpx://user@server/Datacenter/esxi</code></pre>

<p>where:</p>

<dl>

<dt><code>user@</code></dt>
<dd>

<p>is the (optional, but recommended) user to connect as</p>

</dd>
<dt><code>server</code></dt>
<dd>

<p>is the vCenter Server (<i>not</i> hypervisor)</p>

</dd>
<dt><code>Datacenter</code></dt>
<dd>

<p>is the name of the datacenter</p>

</dd>
<dt><code>esxi</code></dt>
<dd>

<p>is the name of the ESXi hypervisor running the guest.</p>

</dd>
</dl>

<p>If the VMware deployment is using clusters and/or folders, then these may need to be added to the URI, eg:</p>

<pre><code> vpx://user@server/Datacenter/cluster1/esxi</code></pre>

<p>For full details of libvirt URIs, see: <a href="http://libvirt.org/drvesx.html">http://libvirt.org/drvesx.html</a></p>

<p>Typical errors from libvirt / virsh when the URI is wrong include:</p>

<ul>

<li><p>Could not find datacenter specified in [...]</p>

</li>
<li><p>Could not find compute resource specified in [...]</p>

</li>
<li><p>Path [...] does not specify a compute resource</p>

</li>
<li><p>Path [...] does not specify a host system</p>

</li>
<li><p>Could not find host system specified in [...]</p>

</li>
</ul>

<h2 id="esx:-test-libvirt-connection-to-vcenter">ESX: TEST LIBVIRT CONNECTION TO VCENTER</h2>

<p>Use the <a href="http://man.he.net/man1/virsh">virsh(1)</a> command to list the guests on the vCenter Server like this:</p>

<pre><code> $ virsh -c &#39;vpx://root@vcenter.example.com/Datacenter/esxi&#39; list --all
 Enter root&#39;s password for vcenter.example.com: ***
 
  Id    Name                           State
 ----------------------------------------------------
  -     Fedora 20                      shut off
  -     Windows 2003                   shut off</code></pre>

<p>If you get an error &quot;Peer certificate cannot be authenticated with given CA certificates&quot; or similar, then you can either import the ESX host&#39;s certificate, or bypass signature verification by adding the <code>?no_verify=1</code> flag:</p>

<pre><code> $ virsh -c &#39;vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1&#39; list --all</code></pre>

<p>You should also try dumping the metadata from any guest on your server, like this:</p>

<pre><code> $ virsh -c &#39;vpx://root@vcenter.example.com/Datacenter/esxi&#39; dumpxml &quot;Windows 2003&quot;
 &lt;domain type=&#39;vmware&#39;&gt;
   &lt;name&gt;Windows 2003&lt;/name&gt;
   [...]
 &lt;/domain&gt;</code></pre>

<p><b>If the above commands do not work, then virt-v2v is not going to work either</b>. Fix your libvirt configuration and/or your VMware vCenter Server before continuing.</p>

<h2 id="esx:-importing-a-guest">ESX: IMPORTING A GUEST</h2>

<p>To import a particular guest from vCenter Server, do:</p>

<pre><code> $ virt-v2v -ic &#39;vpx://root@vcenter.example.com/Datacenter/esxi?no_verify=1&#39; \
   &quot;Windows 2003&quot; \
   -o local -os /var/tmp</code></pre>

<p>where <code>Windows 2003</code> is the name of the guest (which must be shut down).</p>

<p>Note that you may be asked for the vCenter password <i>twice</i>. This happens once because libvirt needs it, and a second time because virt-v2v itself connects directly to the server. Use <i>--password-file</i> to supply a password via a file.</p>

<p>In this case the output flags are set to write the converted guest to a temporary directory as this is just an example, but you can also write to libvirt or any other supported target.</p>

<h1 id="input-from-rhel-5-xen">INPUT FROM RHEL 5 XEN</h1>

<p>Virt-v2v is able to import Xen guests from RHEL 5 Xen hosts.</p>

<p>Virt-v2v uses libvirt for access to the remote Xen host, and therefore the input mode should be <i>-i libvirt</i>. As this is the default, you don&#39;t need to specify it on the command line.</p>

<h2 id="xen:-set-up-ssh-agent-access-to-xen-host">XEN: SET UP SSH-AGENT ACCESS TO XEN HOST</h2>

<p>Currently you must enable passwordless SSH access to the remote Xen host from the virt-v2v conversion server.</p>

<p>You must also use ssh-agent, and add your ssh public key to <code>/root/.ssh/authorized_keys</code> (on the Xen host).</p>

<p>After doing this, you should check that passwordless access works from the virt-v2v server to the Xen host. For example:</p>

<pre><code> $ ssh root@xen.example.com
 [ logs straight into the shell, no password is requested ]</code></pre>

<p>Note that password-interactive and Kerberos access are <b>not</b> supported. You <b>have</b> to set up ssh access using ssh-agent and authorized_keys.</p>

<h2 id="xen:-test-libvirt-connection-to-remote-xen-host">XEN: TEST LIBVIRT CONNECTION TO REMOTE XEN HOST</h2>

<p>Use the <a href="http://man.he.net/man1/virsh">virsh(1)</a> command to list the guests on the remote Xen host:</p>

<pre><code> $ virsh -c xen+ssh://root@xen.example.com list --all
  Id    Name                           State
 ----------------------------------------------------
  0     Domain-0                       running
  -     rhel49-x86_64-pv               shut off</code></pre>

<p>You should also try dumping the metadata from any guest on your server, like this:</p>

<pre><code> $ virsh -c xen+ssh://root@xen.example.com dumpxml rhel49-x86_64-pv
 &lt;domain type=&#39;xen&#39;&gt;
   &lt;name&gt;rhel49-x86_64-pv&lt;/name&gt;
   [...]
 &lt;/domain&gt;</code></pre>

<p><b>If the above commands do not work, then virt-v2v is not going to work either</b>. Fix your libvirt configuration or the remote server before continuing.</p>

<h2 id="xen:-importing-a-guest">XEN: IMPORTING A GUEST</h2>

<p>To import a particular guest from a Xen server, do:</p>

<pre><code> $ virt-v2v -ic &#39;xen+ssh://root@xen.example.com&#39; \
   rhel49-x86_64-pv \
   -o local -os /var/tmp</code></pre>

<p>where <code>rhel49-x86_64-pv</code> is the name of the guest (which must be shut down).</p>

<p>In this case the output flags are set to write the converted guest to a temporary directory as this is just an example, but you can also write to libvirt or any other supported target.</p>

<h1 id="output-to-libvirt">OUTPUT TO LIBVIRT</h1>

<p>The <i>-o libvirt</i> option lets you upload the converted guest to a libvirt-managed host. There are several limitations:</p>

<ul>

<li><p>You can only use a local libvirt connection [see below for how to workaround this].</p>

</li>
<li><p>The <i>-os pool</i> option must specify a directory pool, not anything more exotic such as iSCSI [but see below].</p>

</li>
<li><p>You can only upload to a KVM hypervisor.</p>

</li>
</ul>

<p><b>To output to a remote libvirt instance and/or a non-directory storage pool</b> you have to use the following workaround:</p>

<ol>

<li><p>Use virt-v2v in <i>-o local</i> mode to convert the guest disks and metadata into a local temporary directory:</p>

<pre><code> virt-v2v [...] -o local -os /var/tmp</code></pre>

<p>This creates two (or more) files in <code>/var/tmp</code> called:</p>

<pre><code> /var/tmp/NAME.xml     # the libvirt XML (metadata)
 /var/tmp/NAME-sda     # the guest&#39;s first disk</code></pre>

<p>(for <code>NAME</code> substitute the guest&#39;s name).</p>

</li>
<li><p>Upload the converted disk(s) into the storage pool called <code>POOL</code>:</p>

<pre><code> size=$(stat -c%s /var/tmp/NAME-sda)
 virsh vol-create-as POOL NAME-sda $size --format raw
 virsh vol-upload --pool POOL NAME-sda /var/tmp/NAME-sda</code></pre>

</li>
<li><p>Edit <code>/var/tmp/NAME.xml</code> to change <code>/var/tmp/NAME-sda</code> to the pool name. In other words, locate the following bit of XML:</p>

<pre><code> &lt;disk type=&#39;file&#39; device=&#39;disk&#39;&gt;
   &lt;driver name=&#39;qemu&#39; type=&#39;raw&#39; cache=&#39;none&#39; /&gt;
   &lt;source file=&#39;/var/tmp/NAME-sda&#39; /&gt;
   &lt;target dev=&#39;hda&#39; bus=&#39;ide&#39; /&gt;
 &lt;/disk&gt;</code></pre>

<p>and change two things: The <code>type=&#39;file&#39;</code> attribute must be changed to <code>type=&#39;volume&#39;</code>, and the <code>&lt;source&gt;</code> element must be changed to include <code>pool</code> and <code>volume</code> attributes:</p>

<pre><code> &lt;disk type=&#39;volume&#39; device=&#39;disk&#39;&gt;
   ...
   &lt;source pool=&#39;POOL&#39; volume=&#39;NAME-sda&#39; /&gt;
   ...
 &lt;/disk&gt;</code></pre>

</li>
<li><p>Define the final guest in libvirt:</p>

<pre><code> virsh define /var/tmp/NAME.xml</code></pre>

</li>
</ol>

<h1 id="output-to-rhev">OUTPUT TO RHEV</h1>

<p>This section only applies to the <i>-o rhev</i> output mode. If you use virt-v2v from the RHEV-M user interface, then behind the scenes the import is managed by VDSM using the <i>-o vdsm</i> output mode (which end users should not try to use directly).</p>

<p>You have to specify <i>-o rhev</i> and an <i>-os</i> option that points to the RHEV-M Export Storage Domain. You can either specify the NFS server and mountpoint, eg. <span style="white-space: nowrap;"><code>-os rhev-storage:/rhev/export</code></span>, or you can mount that first and point to the directory where it is mounted, eg. <span style="white-space: nowrap;"><code>-os /tmp/mnt</code></span>. Be careful not to point to the Data Storage Domain by accident as that will not work.</p>

<p>On successful completion virt-v2v will have written the new guest to the Export Storage Domain, but it will not yet be ready to run. It must be imported into RHEV using the UI before it can be used.</p>

<p>In RHEV &ge; 2.2 this is done from the Storage tab. Select the export domain the guest was written to. A pane will appear underneath the storage domain list displaying several tabs, one of which is &quot;VM Import&quot;. The converted guest will be listed here. Select the appropriate guest an click &quot;Import&quot;. See the RHEV documentation for additional details.</p>

<p>If you export several guests, then you can import them all at the same time through the UI.</p>

<h1 id="resource-requirements">RESOURCE REQUIREMENTS</h1>

<h2 id="network">Network</h2>

<p>The most important resource for virt-v2v appears to be network bandwidth. Virt-v2v should be able to copy guest data at gigabit ethernet speeds or greater.</p>

<p>Ensure that the network connections between servers (conversion server, NFS server, vCenter, Xen) are as fast and as low latency as possible.</p>

<h2 id="disk-space">Disk space</h2>

<p>Virt-v2v places potentially large temporary files in <code>$TMPDIR</code> (which is <code>/var/tmp</code> if you don&#39;t set it). Using tmpfs is a bad idea.</p>

<p>For each guest disk, an overlay is stored temporarily. This stores the changes made during conversion, and is used as a cache. The overlays are not particularly large - tens or low hundreds of megabytes per disk is typical. In addition to the overlay(s), input and output methods may use disk space, as outlined in the table below.</p>

<dl>

<dt><i>-i ova</i></dt>
<dd>

<p>This temporarily places a full copy of the uncompressed source disks in <code>$TMPDIR</code>.</p>

</dd>
<dt><i>-o glance</i></dt>
<dd>

<p>This temporarily places a full copy of the output disks in <code>$TMPDIR</code>.</p>

</dd>
<dt><i>-o local</i></dt>
<dd>

</dd>
<dt><i>-o qemu</i></dt>
<dd>

<p>You must ensure there is sufficient space in the output directory for the converted guest.</p>

</dd>
<dt><i>-o null</i></dt>
<dd>

<p>This temporarily places a full copy of the output disks in <code>$TMPDIR</code>.</p>

</dd>
</dl>

<h2 id="vmware-vcenter-resources">VMware vCenter resources</h2>

<p>Copying from VMware vCenter is currently quite slow, but we believe this to be an issue with VMware. Ensuring the VMware ESXi hypervisor and vCenter guest are running on fast hardware with plenty of memory should alleviate this.</p>

<h2 id="compute-power-and-ram">Compute power and RAM</h2>

<p>Virt-v2v is not especially compute or RAM intensive. If you are running many parallel conversions, then you may consider allocating one CPU core and 512 MB - 1 GB of RAM per running instance.</p>

<p>Virt-v2v can be run in a virtual machine.</p>

<h1 id="post-conversion-tasks">POST-CONVERSION TASKS</h1>

<h2 id="guest-network-configuration">Guest network configuration</h2>

<p>Virt-v2v cannot currently reconfigure a guest&#39;s network configuration. If the converted guest is not connected to the same subnet as the source, its network configuration may have to be updated. See also <a href="virt-customize.1.html">virt-customize(1)</a>.</p>

<h2 id="converting-a-windows-guest">Converting a Windows guest</h2>

<p>When converting a Windows guests, the conversion process is split into two stages:</p>

<ol>

<li><p>Offline conversion.</p>

</li>
<li><p>First boot.</p>

</li>
</ol>

<p>The guest will be bootable after the offline conversion stage, but will not yet have all necessary drivers installed to work correctly. These will be installed automatically the first time the guest boots.</p>

<p><b>N.B.</b> Take care not to interrupt the automatic driver installation process when logging in to the guest for the first time, as this may prevent the guest from subsequently booting correctly.</p>

<h2 id="windows-recovery-console">Windows Recovery Console</h2>

<p>Virt-v2v does not support conversion of the Windows Recovery Console. If a guest has a recovery console installed and VirtIO was enabled during conversion, attempting to boot the recovery console will result in a BSOD.</p>

<p>Windows XP x86 does not support the Windows Recovery Console on VirtIO systems, so there is no resolution to this. However, on Windows XP AMD64 and Windows 2003 (x86 and AMD64), the recovery console can be re-installed after conversion. The re-installation procedure is the same as the initial installation procedure. It is not necessary to remove the recovery console first. Following re-installation, the recovery console will work as intended.</p>

<h1 id="free-space-for-conversion">FREE SPACE FOR CONVERSION</h1>

<p>Virt-v2v checks there is sufficient free space in the guest filesystem to perform the conversion. Currently it checks:</p>

<dl>

<dt>Root filesystem or <code>C:\</code></dt>
<dd>

<p>Minimum free space: 20 MB</p>

</dd>
<dt><code>/boot</code></dt>
<dd>

<p>Minimum free space: 50 MB</p>

<p>This is because we need to build a new initramfs for some Enterprise Linux conversions.</p>

</dd>
<dt>Any other mountable filesystem</dt>
<dd>

<p>Minimum free space: 10 MB</p>

</dd>
</dl>

<h1 id="running-virt-v2v-as-root-or-non-root">RUNNING VIRT-V2V AS ROOT OR NON-ROOT</h1>

<p>Nothing in virt-v2v inherently needs root access, and it will run just fine as a non-root user. However, certain external features may require either root or a special user:</p>

<dl>

<dt>Mounting the Export Storage Domain</dt>
<dd>

<p>When using <i>-o rhev -os server:/esd</i> virt-v2v has to have sufficient privileges to NFS mount the Export Storage Domain from <code>server</code>.</p>

<p>You can avoid needing root here by mounting it yourself before running virt-v2v, and passing <i>-os /mountpoint</i> instead, but first of all read the next <span style="white-space: nowrap;">section ...</span></p>

</dd>
<dt>Writing to the Export Storage Domain as 36:36</dt>
<dd>

<p>RHEV-M cannot read files and directories from the Export Storage Domain unless they have UID:GID 36:36. You will see VM import problems if the UID:GID is not correct.</p>

<p>When you run virt-v2v <i>-o rhev</i> as root, virt-v2v attempts to create files and directories with the correct ownership. If you run virt-v2v as non-root, it will probably still work, but you will need to manually change ownership after virt-v2v has finished.</p>

</dd>
<dt>Writing to libvirt</dt>
<dd>

<p>When using <i>-o libvirt</i>, you may need to run virt-v2v as root so that it can write to the libvirt system instance (ie. <code>qemu:///system</code>) and to the default location for disk images (usually <code>/var/lib/libvirt/images</code>).</p>

<p>You can avoid this by setting up libvirt connection authentication, see <a href="http://libvirt.org/auth.html">http://libvirt.org/auth.html</a>. Alternatively, use <i>-oc qemu:///session</i>, which will write to your per-user libvirt instance.</p>

</dd>
<dt>Writing to Glance</dt>
<dd>

<p>This does <i>not</i> need root (in fact it probably won&#39;t work), but may require either a special user and/or for you to source a script that sets authentication environment variables. Consult the Glance documentation.</p>

</dd>
</dl>

<h1 id="debugging-rhev-m-import-failures">DEBUGGING RHEV-M IMPORT FAILURES</h1>

<p>When you export to the RHEV-M Export Storage Domain, and then import that guest through the RHEV-M UI, you may encounter an import failure. Diagnosing these failures is infuriatingly difficult as the UI generally hides the true reason for the failure.</p>

<p>There are two log files of interest. The first is stored on the RHEV-M server itself, and is called <code>/var/log/ovirt-engine/engine.log</code></p>

<p>The second file, which is the most useful, is found on the SPM host (SPM stands for &quot;Storage Pool Manager&quot;). This is a RHEV node that is elected to do all metadata modifications in the data center, such as image or snapshot creation. You can find out which host is the current SPM from the &quot;Hosts&quot; tab &quot;Spm Status&quot; column. Once you have located the SPM, log into it and grab the file <code>/var/log/vdsm/vdsm.log</code> which will contain detailed error messages from low-level commands.</p>

<h1 id="minimal-xml-for--i-libvirtxml-option">MINIMAL XML FOR -i libvirtxml OPTION</h1>

<p>When using the <i>-i libvirtxml</i> option, you have to supply some libvirt XML. Writing this from scratch is hard, so the template below is helpful.</p>

<p><b>Note this should only be used for testing and/or where you know what you&#39;re doing!</b> If you have libvirt metadata for the guest, always use that instead.</p>

<pre><code> &lt;domain type=&#39;kvm&#39;&gt;
   &lt;name&gt;NAME&lt;/name&gt;
   &lt;memory&gt;1048576&lt;/memory&gt;
   &lt;vcpu&gt;2&lt;/vcpu&gt;
   &lt;os&gt;
     &lt;type&gt;hvm&lt;/type&gt;
     &lt;boot dev=&#39;hd&#39;/&gt;
   &lt;/os&gt;
   &lt;features&gt;
     &lt;acpi/&gt;
     &lt;apic/&gt;
     &lt;pae/&gt;
   &lt;/features&gt;
   &lt;devices&gt;
     &lt;disk type=&#39;file&#39; device=&#39;disk&#39;&gt;
       &lt;driver name=&#39;qemu&#39; type=&#39;raw&#39;/&gt;
       &lt;source file=&#39;/path/to/disk/image&#39;/&gt;
       &lt;target dev=&#39;hda&#39; bus=&#39;ide&#39;/&gt;
     &lt;/disk&gt;
     &lt;interface type=&#39;network&#39;&gt;
       &lt;mac address=&#39;52:54:00:01:02:03&#39;/&gt;
       &lt;source network=&#39;default&#39;/&gt;
       &lt;model type=&#39;rtl8139&#39;/&gt;
     &lt;/interface&gt;
   &lt;/devices&gt;
 &lt;/domain&gt;</code></pre>

<h1 id="machine-readable-output">MACHINE READABLE OUTPUT</h1>

<p>The <i>--machine-readable</i> option can be used to make the output more machine friendly, which is useful when calling virt-v2v from other programs, GUIs etc.</p>

<p>There are two ways to use this option.</p>

<p>Firstly use the option on its own to query the capabilities of the virt-v2v binary. Typical output looks like this:</p>

<pre><code> $ virt-v2v --machine-readable
 virt-v2v
 libguestfs-rewrite
 input:disk
 [...]
 output:local
 [...]
 convert:enterprise-linux
 convert:windows</code></pre>

<p>A list of features is printed, one per line, and the program exits with status 0.</p>

<p>The <code>input:</code> and <code>output:</code> features refer to <i>-i</i> and <i>-o</i> (input and output mode) options supported by this binary. The <code>convert:</code> features refer to guest types that this binary knows how to convert.</p>

<p>Secondly use the option in conjunction with other options to make the regular program output more machine friendly.</p>

<p>At the moment this means:</p>

<ol>

<li><p>Progress bar messages can be parsed from stdout by looking for this regular expression:</p>

<pre><code> ^[0-9]+/[0-9]+$</code></pre>

</li>
<li><p>The calling program should treat messages sent to stdout (except for progress bar messages) as status messages. They can be logged and/or displayed to the user.</p>

</li>
<li><p>The calling program should treat messages sent to stderr as error messages. In addition, virt-v2v exits with a non-zero status code if there was a fatal error.</p>

</li>
</ol>

<p>Virt-v2v &le; 0.9.1 did not support the <i>--machine-readable</i> option at all. The option was added when virt-v2v was rewritten in 2014.</p>

<h1 id="files">FILES</h1>

<dl>

<dt><code>/usr/share/virtio-win</code></dt>
<dd>

<p>(Optional)</p>

<p>If this directory is present, then virtio drivers for Windows guests will be found from this directory and installed in the guest during conversion.</p>

</dd>
</dl>

<h1 id="environment-variables">ENVIRONMENT VARIABLES</h1>

<dl>

<dt><code>TMPDIR</code></dt>
<dd>

<p>Location of the temporary directory used for the potentially large temporary overlay file.</p>

<p>See the <a href="#disk-space">&quot;Disk space&quot;</a> section above.</p>

</dd>
<dt><code>VIRT_TOOLS_DATA_DIR</code></dt>
<dd>

<p>This can point to the directory containing data files used for Windows conversion.</p>

<p>Normally you do not need to set this. If not set, a compiled-in default will be used (something like <code>/usr/share/virt-tools</code>).</p>

<p>This directory may contain the following files:</p>

<dl>

<dt><code>rhsrvany.exe</code></dt>
<dd>

<p>(Required when doing conversions of Windows guests)</p>

<p>This is the RHSrvAny Windows binary, used to install a &quot;firstboot&quot; script in the guest during conversion of Windows guests.</p>

<p>See also: <code>https://github.com/rwmjones/rhsrvany</code></p>

</dd>
<dt><code>rhev-apt.exe</code></dt>
<dd>

<p>(Optional)</p>

<p>The RHEV Application Provisioning Tool (RHEV APT). If this file is present, then RHEV APT will be installed in the Windows guest during conversion. This tool is a guest agent which ensures that the virtio drivers remain up to date when the guest is running on Red Hat Enterprise Virtualization (RHEV).</p>

<p>This file comes from Red Hat Enterprise Virtualization (RHEV), and is not distributed with virt-v2v.</p>

</dd>
</dl>

</dd>
</dl>

<p>For other environment variables, see <a href="guestfs.3.html#environment-variables">&quot;ENVIRONMENT VARIABLES&quot; in guestfs(3)</a>.</p>

<h1 id="see-also">SEE ALSO</h1>

<p><a href="virt-p2v.1.html">virt-p2v(1)</a>, <a href="virt-customize.1.html">virt-customize(1)</a>, <a href="virt-df.1.html">virt-df(1)</a>, <a href="virt-filesystems.1.html">virt-filesystems(1)</a>, <a href="virt-sparsify.1.html">virt-sparsify(1)</a>, <a href="virt-sysprep.1.html">virt-sysprep(1)</a>, <a href="guestfs.3.html">guestfs(3)</a>, <a href="guestfish.1.html">guestfish(1)</a>, <a href="http://man.he.net/man1/qemu-img">qemu-img(1)</a>, <a href="http://man.he.net/man8/fstrim">fstrim(8)</a>, <a href="http://libguestfs.org/">http://libguestfs.org/</a>.</p>

<h1 id="authors">AUTHORS</h1>

<p>Richard W.M. Jones <a href="http://people.redhat.com/~rjones/">http://people.redhat.com/~rjones/</a></p>

<p>Matthew Booth</p>

<p>Mike Latimer</p>

<p>Shahar Havivi</p>

<p>Tingting Zheng</p>

<h1 id="copyright">COPYRIGHT</h1>

<p>Copyright (C) 2009-2014 Red Hat Inc.</p>

<h1 id="license">LICENSE</h1>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>

<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</p>

<h1 id="bugs">BUGS</h1>

<p>To get a list of bugs against libguestfs, use this link: <a href="https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools">https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&amp;product=Virtualization+Tools</a></p>

<p>To report a new bug against libguestfs, use this link: <a href="https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools">https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&amp;product=Virtualization+Tools</a></p>

<p>When reporting a bug, please supply:</p>

<ul>

<li><p>The version of libguestfs.</p>

</li>
<li><p>Where you got libguestfs (eg. which Linux distro, compiled from source, etc)</p>

</li>
<li><p>Describe the bug accurately and give a way to reproduce it.</p>

</li>
<li><p>Run <a href="libguestfs-test-tool.1.html">libguestfs-test-tool(1)</a> and paste the <b>complete, unedited</b> output into the bug report.</p>

</li>
</ul>

</body>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-16045969-1");
pageTracker._trackPageview();
} catch(err) {}</script></html>

